руководство по управлению плечом и входом в сделки на Binance Futures (USDC-M)

1. Учет актуальных комиссий Binance Futures USDC-M и расчет чистой прибыли
   Комиссии. На фьючерсах Binance с маржой в USDC сейчас действуют нулевые Maker-комиссии (0%) и очень низкие Taker-комиссии (порядка 0.01% за сделку)​
   binance.com
   ​
   binance.com
   . Это значит, что при размещении лимитного ордера (Maker) вы комиссию не платите, а при рыночном ордере (Taker) комиссия совсем малая. Однако даже эти небольшие издержки нужно учитывать при расчете прибыли. Комиссия взимается и при открытии позиции, и при ее закрытии, поэтому общий издержки на комиссию примерно удваиваются. Формула комиссии. Для каждой стороны сделки комиссия рассчитывается как произведение объема и цены на ставку комиссии. Например​
   binance.com
   :
   Комиссия при входе = (количество контрактов × цена входа) × ставка комиссии.
   Комиссия при выходе = (количество контрактов × цена выхода) × ставка комиссии.
   Если открытие и закрытие произошли по рыночным ценам, то обе части комиссии будут равны по величине (ставка та же 0.01% для тейкера). В итоге общая комиссия за круг (round-trip) примерно:
   scss
   Copy
   Комиссия*общая ≈ 2 × (количество × средняя цена × ставка*комиссии).
   Эту формулу и заложим в расчет чистой прибыли. Чистая прибыль = валовая прибыль от движения цены – комиссия_общая. Даже при малых комиссиях важно убедиться, что они не «съедят» большую часть заработка. В коде бота следует вычитать комиссию при расчете ожидаемой прибыли. Например, для тейкер-комиссии 0.01%: если позиция объёмом $100 приносит валовую прибыль $1 (1%), то комиссия за вход+выход составит ~$0.02 (0.02% от $100)​
   binance.com
   . Чистая прибыль будет ~$0.98. Хотя эта комиссия невелика, при очень маленьких профитах ею нельзя пренебрегать – особенно на малых депозитах, где прибыль с одной сделки может быть несколько центов.
2. Градация минимальной чистой прибыли в зависимости от депозита
   Чтобы защитить результаты торговли на небольшом балансе, вводится градация минимальной цели по чистой прибыли в долларах, в зависимости от размера депозита:
   Депозит до $50 USDC – минимальная чистая прибыль с сделки: $0.3.
   Депозит до $100 USDC – минимальная чистая прибыль: $0.5.
   Депозит до $500 USDC – минимальная чистая прибыль: $1.
   Депозит выше $500 USDC – минимальная чистая прибыль: $2.
   Этот порог означает, что стратегия будет нацелена не принимать сделки с ожидаемой чистой прибылью ниже указанных значений. Зачем это нужно? На малых депозитах абсолютная прибыль в долларах совсем невелика, и ее может съесть комиссия или рыночный шум. Например, на депозите $30 сделка с доходностью 1% даст всего ~$0.30 валовой прибыли – после уплаты комиссии останется ~$0.25, что меньше целевого минимума $0.3. Поэтому бот либо не войдет в такую сделку, либо постарается увеличить её потенциал (например, чуть повысив целевой профит в процентах или объем позиции) чтобы выйти на минимум $0.3 чистыми. С увеличением депозита порог растет, но не линейно – целью является гарантировать ощутимую прибыль, но не завышать требования. Для крупных депозитов (>$500) $2 – это очень консервативный минимум (менее 0.5%), который легко превышается практически каждой прибыльной сделкой, поэтому порог главным образом актуален для мелких счетов.
   Примечание: Эти значения можно настроить. Разработчику стоит вынести их в конфигурацию. Например, можно создать словарь вроде MIN_NET_PROFIT = {50: 0.3, 100: 0.5, 500: 1.0, 'max': 2.0} и функцию для получения целевого минимума по текущему балансу. В дальнейшем, если комиссии Binance изменятся или стратегия будет меняться, эти пороги можно скорректировать.
3. Логика установки целей Take-Profit (TP1 и TP2)
   Стратегия бота использует два уровня тейк-профита (TP1 и TP2), чтобы зафиксировать часть прибыли и дать оставшейся позиции «поработать» дальше. Такое частичное взятие прибыли соответствует лучшим практикам риск-менеджмента: фиксируя часть прибыли на TP1 и передвигая стоп-лосс в безубыток, трейдер гарантирует положительный результат, а остальную часть позиции держит на более дальнюю цель​
   binance.com
   . В нашем боте реализована аналогичная логика: на TP1 продается 70% позиции, на TP2 – оставшиеся 30% (коэффициенты настраиваются параметрами TP1*SHARE и TP2_SHARE). Процентные уровни TP. В конфигурации заданы базовые уровни: TP1_PERCENT = 0.007 (0.7% от цены входа) и TP2_PERCENT = 0.013 (1.3% от цены входа). Это означет, например, для лонга:
   TP1 = цена входа * 1.007 (то есть +0.7%),
   TP2 = цена входа _ 1.013 (+1.3%).
   Для шорта аналогично, но вниз от цены входа (–0.7% и –1.3% соответственно). Stop-loss (SL) установлен по умолчанию на 1% от цены против направления сделки (SL_PERCENT = 0.01), то есть убыток в случае срабатывания SL ~1% от цены входа. Адаптация к условиям рынка. Бот динамически корректирует эти уровни в зависимости от волатильности рынка. Если рынок флетовый (низкая волатильность), бот уменьшает цели TP и сужает стоп (множитель FLAT_ADJUSTMENT = 0.7 по умолчанию). То есть в спокойном рынке TP1 может быть ~0.5% вместо 0.7%, а TP2 ~0.9% вместо 1.3%. Это повышает шанс, что цели будут достигнуты даже при слабом движении. Если же рынок трендовый, бот может увеличить TP2 (напр. умножить на TREND_ADJUSTMENT = 1.3, т.е. TP2 ~1.69% вместо 1.3%) – чтобы постараться взять больше прибыли по второй части в сильном движении. Стоп-лосс при трендовом режиме тоже чуть раздвигается (чтобы не выбило по мелкой коррекции). Эти механизмы управляются флагом AUTO_TP_SL_ENABLED и функцией анализа волатильности get_market_regime(). Таким образом, TP1/TP2 гибко подстраиваются: в узком рынке цели ближе, в тренде – дальше. Пример расчета TP1/TP2 и прибыли. Рассмотрим конкретный сценарий для депозита $80 USDC (порог min чистой прибыли $0.5) в нормальных условиях рынка (без коррекции flat/trend):
   Вход в позицию: Пусть бот находит сигнал на покупку (лонг) по цене $100 (например, это цена базового актива в паре
   𝐶
   𝑂
   𝐼
   𝑁
   COIN/USDC). Текущий баланс $80, поэтому бот отнесет его к категории “до $100”. Согласно управлению рисками, для балансов < $100 берем риск на сделку 3% от депо (функция get_adaptive_risk_percent возвращает 0.03) – это $2.4. Стоп-лосс 1% вниз от $100 – то есть на $99.00. Таким образом, на 1 единице актива риск потерять $1 (с $100 до $99). Чтобы риск в $2.4 соблюдался, бот рассчитает количество контрактов: qty = risk_amount / (entry_price _ SL*PERCENT). В нашем случае qty = 2.4 / (100 * 0.01) = 2.4 / 1 = 2.4 контракта. (Другими словами, номинал позиции $100 _ 2.4 = $240, что эквивалентно 3× размеру депозита – задействуем кредитное плечо 3x на эту сделку.) Эта расчётная функция вынесена в модуль order_utils.py (см. ниже). Бот открывает позицию объёмом 2.4 контракта по $100.
   Установка целей: Рассчитаем TP1 и TP2 по базовым процентам:
   TP1 цена = $100 _ 1.007 = $100.70.
   TP2 цена = $100 _ 1.013 = $101.30.
   Бот выставляет лимитные ордера на продажу: на 1.68 контракта по $100.70 (это 70% от 2.4) и на 0.72 контракта по $101.30 (30% от позиции), с параметром reduceOnly=True (чтобы закрывать существующую позицию, не открывая новую). Одновременно ставится стоп-ордер (STOP_MARKET) на всю позицию 2.4 контракта по цене $99.00.
   Фиксация прибыли на TP1: Если цена вырастет до $100.70, сработает первый тейк-профит: продастся 1.68 контрактов. Прибыль на TP1 составит 0.7% от цены на эту закрытую часть. В долларах это: 1.68 × ($100.70 – $100.00) = $1.176. После этого у бота останется 0.72 контракта в лонге.
   Движение стоп-лосса в безубыток: Благодаря модулю break-even (ENABLE_BREAKEVEN=True), после срабатывания TP1 бот автоматически подтянет стоп-лосс оставшейся позиции к цене входа ($100). Это гарантирует, что оставшиеся 0.72 контракта уже не уйдут в убыток – худший сценарий, что остаток закроется по безубытку. Таким образом, после TP1 прибыль $1.176 уже зафиксирована и дальше позиция либо даст ещё прибыль на TP2, либо закроется по нулю (или по трейлинг-стопу, если включен ENABLE_TRAILING). Этот прием обеспечивает, что как минимум минимальная прибыль ($0.5 для депо $80) сохранится​
   binance.com
   .
   Фиксация прибыли на TP2: Если рынок продолжит расти до $101.30, сработает второй тейк-профит на оставшиеся 0.72 контракта. Прибыль на TP2 составит 1.3% от цены входа на эту часть позиции: 0.72 × ($101.30 – $100.00) = $0.936.
   Итог по сделке: Валовая прибыль суммарно = $1.176 + $0.936 = $2.112. Теперь вычтем комиссии. Предположим, бот открывал позицию маркет-ордером (taker) и тейк-профиты сработали лимитными ордерами (maker). В худшем случае, если бы и TP исполнились как рыночные, комиссия была бы максимальной. Посчитаем по максимуму (двойная тейкер-комиссия 0.01%):
   Комиссия при входе: 2.4 контракта _ $100 \* 0.01% = $0.024.
   Комиссия при выходе (TP1+TP2 суммарно тот же объём 2.4 контракта): ≈ $0.024 (почти то же, так как цена выхода ~ цена входа).
   Итого комиссия ≈ $0.048.
   Чистая прибыль ≈ $2.112 – $0.048 = $2.064. Это значительно выше минимального порога $0.5 для данного депозита, т.е. план выполнен с запасом. Даже если бы только TP1 достигся, мы бы заработали ~$1.17 минус комиссию ~$0.03, чисто ~$1.14, что тоже выше $0.5. Таким образом, благодаря системе частичных тейк-профитов и ограничению риска 1% на стоп, даже на счете <$100 сделка даёт больше минимально требуемого.
   Учёт минимальной прибыли. В редких случаях (например, очень низкая волатильность или совсем крохотный депозит) расчетная чистая прибыль может оказаться ниже требуемого минимума. Тогда бот либо не будет входить в такую сделку, либо (если реализовать улучшение) может слегка увеличить цели TP в процентах или объем позиции. Например, мог бы поднять TP1/TP2 на пару десятых процента, чтобы дотянуть ожидаемую прибыль до порога. Но предпочтительнее просто избегать невыгодных сделок: фильтр MIN_NOTIONAL = 5 уже не дает открывать совсем маленькие позиции. Кроме того, переключение стратегии фильтров на “default_light” для баланса < $100 (см. FILTER_THRESHOLDS в конфиге) старается повысить качество сигналов, чтобы каждая сделка была перспективной. Таким образом, система стремится обеспечить чистую прибыль не ниже заданной планки для любого депозита.
4. Выделение модулей order_utils.py и tp_utils.py
   Разделение логики на отдельные модули повысит ясность и удобство сопровождения кода. Предлагается вынести расчеты объема ордера и тейк-профитов в утилитные модули:
   order_utils.py – расчет размера позиции (количества контрактов) и связанная с этим логика.
   tp_utils.py – расчет целей TP1, TP2 (а при необходимости и уровней стоп-лосса) на основе входных данных.
   Причины для выделения:
   Читаемость и поддержка кода. Логика расчета объема ордера и тейк-профитов довольно обширна (учет баланса, риска, плеча, долей TP, режимов рынка и т.д.). Если оставить её внутри основного движка торговли, файл trade_engine.py или стратегия получится перегруженной деталями. Выделив в отдельные утилиты, мы получим более чистый основной код, а детали вычислений инкапсулируем в функциях. Это облегчает понимание: разработчик сразу видит, что, например, qty = calculate_order_quantity(...) – и может при необходимости заглянуть в реализацию в order_utils.py.
   Повторное использование и тестирование. Вынесенные функции легко переиспользовать в разных местах. Например, функция расчета объема ордера может пригодиться при оценке различных сценариев (симуляции) или в будущих стратегиях. Их проще тестировать по отдельности (unit tests), подкладывая различные входные параметры (баланс, цена, риск) и проверяя корректность результата. Если логика в одном месте, меньше шанс допустить рассинхрон.
   Гибкость настройки. Когда условия рынка меняются или стратегия дорабатывается, бывает нужно скорректировать, скажем, формулу расчета тейк-профита. Вынесенная в tp_utils.py функция позволит сделать это быстро, не затрагивая остальной код. Например, можно сделать несколько вариантов функций TP (агрессивный стиль, консервативный стиль) и выбирать их. Или же легко добавить учет порога минимальной прибыли прямо внутри функции расчета TP – например, повышать TP2, если расчетная прибыль выходит ниже требуемой.
   Пример реализации order_utils.calculate_order_quantity:
   python
   Copy

# order_utils.py

def calculate*order_quantity(entry_price: float, balance: float, risk_ratio: float = 0.01) -> float:
"""Вычислить количество контрактов для ордера на основе цены входа и риск-менеджмента."""
notional = balance * risk*ratio # доля депозита, которую готовы рискнуть
qty = notional / entry_price # сколько контрактов на эту сумму по текущей цене
return round(qty, 3)
Эта простая функция вычисляет объем позиции исходя из заданного соотношения риска к балансу. По умолчанию risk_ratio=0.01 (1% от баланса). В реальности у нас риск зависит от баланса динамически (0.03, 0.05, 0.07), поэтому вызывать ее стоит как:
python
Copy
risk_pct = get_adaptive_risk_percent(balance) # получаем 0.03, 0.05 или 0.07 в зависимости от баланса
quantity = calculate_order_quantity(entry_price, balance, risk_pct)
Далее, возможно, имеет смысл доработать функцию, чтобы она учитывала еще дистанцию до стоп-лосса. В текущей версии мы грубо считаем риск как % от баланса, но более точно риск на сделку = %от депо, реализуется при известном стоп-лоссе. Можно расширить так:
python
Copy
def calculate_order_quantity(entry_price: float, stop_price: float, balance: float, risk_percent: float) -> float:
risk_amount = balance * risk_percent
risk_per_contract = abs(entry_price - stop_price)
qty = risk_amount / risk_per_contract
return round(qty, 3)
Эта версия напрямую реализует формулу: объем = риск в $ / риск на 1 контракт. Такой подход уже используется внутри ядра (trade_engine.calculate_position_size), и его можно перенести в order_utils для консистентности. Пример реализации tp_utils.calculate_tp_levels:
python
Copy

# tp_utils.py

from config import TP1*PERCENT, TP2_PERCENT, SL_PERCENT, TP1_SHARE, TP2_SHARE
def calculate_tp_levels(entry_price: float, side: str, regime: str = None):
"""Вычислить цены TP1 и TP2 в зависимости от цены входа, стороны позиции и режима рынка.""" # 1. Базовые проценты из конфига
tp1_pct = TP1_PERCENT
tp2_pct = TP2_PERCENT
sl_pct = SL_PERCENT # 2. Коррекция под рынок
if regime == "flat":
tp1_pct *= 0.7
tp2*pct *= 0.7
sl*pct *= 0.7
elif regime == "trend":
tp2*pct *= 1.3
sl*pct *= 1.3 # (При необходимости можно учесть score, как в основном коде, здесь опущено) # 3. Рассчет цен уровней
if side.lower() == "buy":
tp1*price = entry_price * (1 + tp1*pct)
tp2_price = entry_price * (1 + tp2*pct) if tp2_pct else None
sl_price = entry_price * (1 - sl*pct)
else: # side == "sell"
tp1_price = entry_price * (1 - tp1*pct)
tp2_price = entry_price * (1 - tp2_pct) if tp2_pct else None
sl_price = entry_price \* (1 + sl_pct)
return round(tp1_price, 4), round(tp2_price, 4) if tp2_price else None, round(sl_price, 4)
Эта функция возвращает рассчитанные уровни TP1, TP2 и SL. Мы можем вызывать ее при открытии сделки:
python
Copy
tp1, tp2, sl = calculate_tp_levels(entry_price, side, regime)
Далее полученные цены используются для выставления ордеров. Логика вычисления здесь повторяет то, что ранее было «зашито» в trade_engine – теперь она в утилите и ее легко менять. Например, можно внутри сравнить ожидаемую прибыль с минимальной ($) и при необходимости увеличить tp2_pct. Такое улучшение можно добавить: вычислить ожидаемую чистую прибыль (по формуле как в примере выше) и если она < требуемого минимума – задать коэффициент усиления для TP. Итак, выделение order_utils и tp_utils делает код чище, облегчает настройку стратегии под разные условия. Разработчику рекомендуется вынести текущие расчеты из trade_engine.py в эти модули и добавить их импорт в нужных местах. После этого все магические числа (проценты TP, риск и т.п.) будут централизованно лежать в конфиге и утилитах, а основной алгоритм станет проще для восприятия. 5. Управление плечом: проверка текущей реализации и автоматизация установки
Текущее использование плеча. В конфигурации бота задан словарь LEVERAGE_MAP, который содержит желаемое плечо для каждого торгового инструмента (пары). Например, для BTC/USDC указано 5, для альткоинов типа DOGE/USDC – 10. Однако важно понять, что просто наличие этого словаря не устанавливает плечо на бирже автоматически. Если не вызвать специальный метод API, Binance будет использовать последнее установленное плечо или значение по умолчанию (как правило, 20x). Сейчас бот, судя по коду, явно не вызывает установку плеча – то есть, возможно, вы вручную устанавливали плечо на бирже для каждой пары или полагаетесь на дефолт. Это место стоит улучшить. Автоматическая установка плеча. Благо, CCXT (и напрямую Binance API) позволяют программно выставить плечо. Перед началом торговли (например, при запуске бота или при добавлении новой пары) имеет смысл вызвать метод exchange.set_leverage(leverage, symbol). Эта операция задаст нужное плечо на сервере Binance. Рекомендуется установить плечо сразу после инициализации биржи и выбора активных символов. Например:
python
Copy

# После exchange = ccxt.binance(...), и после получения списка symbols:

for symbol in SYMBOLS*ACTIVE:
lev = LEVERAGE_MAP.get(symbol, 5) # по умолчанию 5 если не указано
exchange.set_leverage(lev, symbol)
Как отмечает документация, установку плеча лучше выполнить до размещения ордеров​
stmoonar.xlog.page
. Метод set_leverage принимает желаемое значение и символ. После этого Binance будет рассчитывать маржу исходя из этого плеча, и вы не получите ошибку из-за превышения лимита. Например, если вы хотите ограничить BTC/USDC плечом 5x, а бот попробует открыть позицию большего размера, биржа не позволит (или сразу рассчитает, сколько маржи нужно). Без этой установки могла произойти ситуация, что бот (ориентируясь на risk %) открывает позицию $7000 на балансе $1000 (что эквивалент ~7x), а вы планировали максимум 5x – если плечо на Binance все еще 5x, ордер отклонится из-за недостаточной маржи. Или обратная ситуация: вы думаете, что ограничили риск 5x, а на деле биржа все еще разрешает 20x и бот мог бы занять больше. Поэтому синхронизация плеча через API – обязательна для консистентности настроек. Cross vs Isolated. Еще один аспект – режим маржи: кросс или изолированная. По умолчанию в конфиге используется Cross (общая маржа для всех позиций). Это означает, что все позиции используют единый пул маржи (ваш общий баланс USDC), и ликвидация по одной позиции может затронуть весь счет. Преимущество Cross – гибкое использование средств: свободная маржа автоматически перераспределяется, снижение риска принудительной ликвидации отдельной позиции (ее поддержит весь баланс). Недостаток – высокая взаимосвязь позиций: одна большая просадка может съесть баланс и привести к ликвидации всех позиций. Isolated режим наоборот выделяет маржу на каждую сделку отдельно, ограничивая потенциальный убыток этой суммой. Binance по умолчанию держит Cross, но вы можете переключать режим через API: метод exchange.set_margin_mode(symbol, marginType), где marginType = "ISOLATED" или "CROSSED"​
stackoverflow.com
. В нашем случае Cross-маржа оставляется по умолчанию. Это оправдано для небольших депозитов, чтобы все средства работали под все позиции. Но имейте в виду: будьте осторожны с Cross-плечом, так как оно ставит под угрозу весь счет при большом плече​
binance.com
. Если вы хотите обезопаситься от этого, можно переключить на изолированную маржу, ценой того, что придется тщательно следить за каждым позиционным плечом вручную. В режиме Cross достаточно задать плечо через set_leverage – дальше биржа сама обеспечит, чтобы вы не превысили допустимый размер позиции относительно всего баланса. Рекомендации по выбору плеча. Стратегия бота уже предполагает довольно консервативные плечи: 5× для крупных монет (BTC, ETH и т.д.) и 10× для более мелких. Это согласуется с общими рекомендациями не использовать чрезмерно высокое кредитное плечо​
binance.com
. Новичкам обычно советуют 2x-5x, и наши настройки находятся в этом диапазоне для основных активов. Не стоит гнаться за максимумом, даже если Binance позволяет до 50x или 75x – такие плечи могут мгновенно уничтожить депозит при сильном движении против позиции​
binance.com
. Наш подход: плечо используется главным образом для повышения эффективности капитала, а не для сверхриска. Например, в примере выше бот использовал только 3x из доступных 10x на DOGE – т.е. задействовал ровно столько, сколько требовалось под выбранный риск 3% и стоп 1%. Плечо ограничивает максимальный размер позиции, но бот зачастую возьмет меньше, исходя из risk management. Таким образом, настройки плеча в LEVERAGE_MAP скорее служат верхней границей. Убедитесь, что они соответствуют вашим намерениям по риску. В коде можно дополнительно контролировать плечо при расчетах: например, после определения quantity и entry_price проверить, что quantity * entry*price не превышает balance * max_leverage. Но раз мы и так соблюдаем риск-процент, это, как правило, не произойдет (если только risk_percent очень велик). Тем не менее, лишняя проверка не помешает: при аномальных ситуациях (например, баланс сильно вырос, а плечо в конфиге осталось маленьким) бот может решить не открывать слишком большую позицию. 6. Вывод: гибкость системы и гарантированная прибыльность
После внесения описанных обновлений наша система станет более гибкой и адаптивной к разным условиям, сохраняя при этом фокус на контроле риска и гарантированной минимальной прибыли. Что удалось улучшить:
Актуализация комиссий: мы учли последние изменения комиссий Binance Futures USDC-M (0% мейкер, низкий тейкер) и встроили их расчет в логику. Это предотвратит ситуации, когда комиссия недооценена и «съедает» значимую долю профита. Формула комиссии включена в расчеты прибыли, что особенно важно для мелких сделок.
Защита мелкого депозита: введены минимальные цели прибыли в абсолютных цифрах. Теперь бот стремится не делать сделки, которые принесут копейки. Это важно для мотивации и для преодоления порога комиссий. Особенно для депо до 100 USDC – гарантируем хотя бы $0.3–0.5 с каждой удачной сделки чистыми. Таким образом, доходность маленького счета становится ощутимее, прогресс будет заметен.
Частичный тейк-профит с примерами: логика TP1/TP2 подробно расписана и проиллюстрирована примером. Теперь понятно, как рассчитываются уровни, как доли позиции фиксируются, как срабатывает безубыток. Разработчик может при необходимости подправить проценты или доли, зная их эффект. Подход с двумя тейками соответствует рекомендациям опытных трейдеров​
binance.com
: забирать часть прибыли и позволять оставшейся позиции попытаться принести больше. Это улучшает соотношение риск/прибыль и психологически облегчает торговлю (есть чувство достижения цели на TP1, и одновременно шанс на бонус на TP2).
Модульность и расширяемость: выделение order_utils и tp_utils закладывает основу для более чистой архитектуры. Теперь добавлять новые правила (например, третий тейк-профит, динамический трейлинг-стоп и пр.) будет проще, не рискуя сломать основной движок. Код стал организован в соответствии с принципом единственной ответственности: каждый модуль отвечает за свою часть вычислений.
Контроль плеча и маржи через API: мы устранили потенциальный пробел, добавив автоматическую установку плеча. Бот теперь сам выставит нужное плечо для каждой пары при запуске​
stmoonar.xlog.page
, исключая рассинхрон между настройками и реальностью на бирже. Учет режима Cross/Isolated позволяет пользователю понимать, как управляется маржа. По умолчанию остается Cross, что удобно и эффективно использовать весь депозит, но в руководстве разъяснены риски и при желании есть возможность переключиться на изолированную маржу​
binance.com
.
В заключение, данные улучшения делают бота более надежным и прибыльным на разных размерах баланса. Маленький счет теперь защищен от бесполезных сделок – каждая сделка должна приносить хотя бы минимально значимую прибыль после комиссии. Большой счет тоже выигрывает от гибкой системы: доли риска и плечи масштабируются, цели подстраиваются под тренды, что позволяет эффективно торговать без ручного вмешательства. Разработчику стоит протестировать эти изменения на истории и в симуляции, чтобы убедиться в их корректности и достаточности. Но в целом, принципы обновленной логики соответствуют лучшим практикам: минимизировать издержки, контролировать риск и последовательно наращивать капитал. Успешной торговли! 🚀

====================================================================================================

Ниже я приведу подробное руководство с учётом рекомендаций от Грока, моих предыдущих выводов и текущего состояния системы. Это руководство охватывает следующие ключевые аспекты:

Учет комиссий и расчет чистой прибыли

Адаптивная настройка минимальной чистой прибыли в зависимости от депозита

Логика расчёта TP1/TP2 с динамической адаптацией

Выделение логики расчёта объёма ордеров и целей тейк-профита в модули (order_utils.py и tp_utils.py)

Автоматическая установка плеча через API

1. Учет комиссий и расчет чистой прибыли
   Комиссии Binance Futures (USDC-M):
   Мейкер: 0%

Тейкер: примерно 0.01% (с учётом возможного изменения, возьмём conservative: 0.0001)

Расчёт чистой прибыли:
При открытии и закрытии позиции комиссия рассчитывается дважды, поэтому ожидаемая чистая прибыль определяется как:

# Чистая прибыль

Валовая прибыль
−
2
×
(
Объём
×
Цена входа
×
ставка комиссии
)
Чистая прибыль=Валовая прибыль−2×(Объём×Цена входа×ставка комиссии)
Например, если:

Цена входа = $100,

TP1 задан на +0.7% (то есть $100.70),

Количество TP1 части = 70% от всего объёма,

Тогда валовая прибыль на TP1 = (TP1 – цена входа) × (кол-во × 0.7).

Мы рассчитываем комиссию для всей позиции (по обе стороны), после чего сравниваем полученное значение с минимальным порогом чистой прибыли.

2. Адаптивная настройка минимальной чистой прибыли
   Предлагается разделить минимальную чистую прибыль по депозитам следующим образом:

Депозит до $50: минимальная чистая прибыль ≈ $0.3

Депозит до $100: минимальная чистая прибыль ≈ $0.5

Депозит до $500: минимальная чистая прибыль ≈ $1.0

Депозит свыше $500: минимальная чистая прибыль ≈ $2.0

Для реализации это можно добавить в конфиг:

python
Copy

# config.py

TAKER_FEE_RATE = 0.0001 # 0.01%
MIN_NET_PROFIT = {50: 0.3, 100: 0.5, 500: 1.0, 'max': 2.0}

def get_min_net_profit(balance):
for threshold in sorted(k for k in MIN_NET_PROFIT if k != 'max'):
if balance <= threshold:
return MIN_NET_PROFIT[threshold]
return MIN_NET_PROFIT['max']
В функции входа (например, should_enter_trade) добавим проверку ожидаемой чистой прибыли:

python
Copy

# В should_enter_trade:

entry*price = df["close"].iloc[-1]
tp1_price = calculate_tp1(entry_price)
qty = calculate_order_quantity(entry_price, balance)
expected_pnl = abs(tp1_price - entry_price) * qty
min*target_pnl = 0.5 if balance <= 70 else max(0.6, balance * 0.006)
if expected_pnl < min_target_pnl:
log(f"⚠️ Skipping {symbol} — expected PnL ${expected_pnl:.2f} < min ${min_target_pnl:.2f}", level="DEBUG")
return None
Эта проверка позволит боту не входить в сделки, где, после вычета комиссии, прибыль окажется ниже заданного порога.

3. Логика расчёта TP1/TP2 с динамической адаптацией
   Стратегия предполагает использование двух уровней тейк-профита:

TP1: Например, +0.7% от цены входа

TP2: Например, +1.3% от цены входа

SL: -1% от цены входа

В зависимости от рыночного режима (flat/trend) уровни могут корректироваться:

Flat режим: умножаем TP и SL на коэффициент (например, 0.7)

Trend режим: TP2 можно увеличить (например, умножить на 1.3), SL – соответственно, скорректировать

Для ясности и модульности рекомендуется вынести расчёт этих уровней в отдельный модуль tp_utils.py.

Пример функции:

python
Copy

# tp_utils.py

from config import TP1_PERCENT, TP2_PERCENT, SL_PERCENT, FLAT_ADJUSTMENT, TREND_ADJUSTMENT, AUTO_TP_SL_ENABLED

def calculate_tp_levels(entry_price: float, side: str, regime: str = None, score: float = 5):
tp1_pct = TP1_PERCENT
tp2_pct = TP2_PERCENT
sl_pct = SL_PERCENT

    if AUTO_TP_SL_ENABLED and regime:
        if regime == "flat":
            tp1_pct *= FLAT_ADJUSTMENT
            tp2_pct *= FLAT_ADJUSTMENT if tp2_pct else None
            sl_pct *= FLAT_ADJUSTMENT
        elif regime == "trend":
            tp2_pct *= TREND_ADJUSTMENT if tp2_pct else None
            sl_pct *= TREND_ADJUSTMENT

    if side.lower() == "buy":
        tp1_price = entry_price * (1 + tp1_pct)
        tp2_price = entry_price * (1 + tp2_pct) if tp2_pct else None
        sl_price  = entry_price * (1 - sl_pct)
    else:
        tp1_price = entry_price * (1 - tp1_pct)
        tp2_price = entry_price * (1 - tp2_pct) if tp2_pct else None
        sl_price  = entry_price * (1 + sl_pct)
    return round(tp1_price, 4), (round(tp2_price, 4) if tp2_price else None), round(sl_price, 4)

Эту функцию можно использовать как часть логики выставления ордеров в trade_engine.py.

4. Модульность: order_utils.py и tp_utils.py
   order_utils.py
   Ответственна за расчёт объёма ордера (количество контрактов) с учётом входной цены, стоп-цены и риск-процента.

Пример:

python
Copy

# order_utils.py

def calculate_order_quantity(entry_price: float, stop_price: float, balance: float, risk_percent: float) -> float:
"""Вычисляет количество контрактов для ордера на основе заданного риска."""
risk_amount = balance \* risk_percent
risk_per_contract = abs(entry_price - stop_price)
qty = risk_amount / risk_per_contract if risk_per_contract > 0 else 0
return round(qty, 3)
tp_utils.py
Как описано выше, отвечает за вычисление TP1, TP2 и SL.

Это разделение логики делает код более модульным, улучшает его читаемость и облегчает тестирование отдельных элементов.

5. Автоматическая установка плеча через API
   В текущем состоянии в конфиге есть LEVERAGE_MAP, но настройки не устанавливаются автоматически через API. Рекомендуется добавить следующую функцию в, например, utils_core.py:

python
Copy

# utils_core.py (дополнение)

def set_leverage_for_symbols(symbols):
for symbol in symbols:
leverage = LEVERAGE_MAP.get(symbol, 5)
try:
exchange.set_leverage(leverage, symbol)
log(f"Set leverage for {symbol} to {leverage}x", level="INFO")
except Exception as e:
log(f"Failed to set leverage for {symbol}: {e}", level="ERROR")
Затем вызови эту функцию при запуске бота (например, в главном файле после загрузки символов).

Итог и рекомендации
По итогам:

Учет комиссий и минимальной чистой прибыли: Реализуем проверку ожидаемой чистой прибыли с учетом комиссий. Это критично для малых депозитов, чтобы сделки действительно приносили прибыль выше заданного порога.

Адаптивная логика TP: Используем функции из tp_utils.py для динамического расчета уровней TP/SL в зависимости от рыночного режима.

Модульность: Разделение на order_utils.py и tp_utils.py повысит удобство сопровождения кода и ускорит тестирование.

Управление плечом: Автоматизируем установку плеча через API, чтобы настройки в конфиге (LEVERAGE_MAP) полностью соответствовали торговым условиям.

Режимы маржи: По умолчанию используется Cross-маржа для малых депозитов, что удобно, но всегда можно переключиться на изолированную, если потребуется более жесткое управление риском.

Эти рекомендации полностью согласуются с выводами отчёта Грока и нашими предыдущими наблюдениями. Такой подход обеспечит гибкость системы, повысит её эффективность и позволит сохранять чистую прибыль даже на небольшом депозите, при этом защищая капитал от чрезмерных комиссий и ненужных рисков.

==========================================================
мелкие уточнения:

Учет комиссий и чистой прибыли.
Рекомендация учитывать комиссии (тейкер ~0,01% на вход и выход) и проверять ожидаемую чистую прибыль перед входом в сделку – это очень важно, особенно для небольших депозитов. Например, для счета до 50 USD минимальная чистая прибыль должна быть около 0,3 USD, для 50–100 USD – примерно 0,5 USD, а при больших суммах порог растет. Это позволит избежать сделок, где комиссии "съедают" всю прибыль.

Адаптивная настройка TP1/TP2.
Разделение логики расчёта уровней тейк-профита (TP1 для 70% позиции, TP2 для оставшихся 30%) с динамической коррекцией в зависимости от рыночного режима (флэт или тренд) улучшает риск-менеджмент. Такой подход позволяет более гибко управлять сделками и зафиксировать прибыль даже при небольших движениях цены.

Модульность кода.
Предложение вынести расчёты объёма ордеров в отдельный модуль (order_utils.py) и расчёт уровней тейка в tp_utils.py делает код более структурированным и облегчает сопровождение, тестирование и возможное последующее расширение. Это также помогает изолировать сложные математические расчёты и гарантировать, что изменения в одном модуле не затрагивают общий движок.

Автоматизация управления плечом.
Автоматическая установка плеча через API (с использованием LEVERAGE_MAP) гарантирует, что желаемые параметры риска будут соблюдены. Это особенно важно, когда речь идёт о небольших депозитах, где расхождение между настроенным и реальным плечом может привести к ненужным рискам.

Обработка ошибок и детальное логирование.
Рекомендация добавить более детальное логирование (например, в функциях should_enter_trade и enter_trade) и использовать повторные попытки (safe_call_retry) при вызовах API для установки плеча, расчёта ордеров и выставления тейков, сделает систему более надежной и прозрачной для мониторинга.
