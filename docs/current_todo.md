–ö–ª—é—á–µ–≤—ã–µ –º–æ–º–µ–Ω—Ç—ã
–ò—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏—è –ø–æ–∫–∞–∑—ã–≤–∞—é—Ç, —á—Ç–æ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–Ω—ã–µ –¥–æ—Ä–∞–±–æ—Ç–∫–∏ (—à–∞–≥ 3: –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ last_trade_times, —à–∞–≥ 4: –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ TP/SL, —à–∞–≥ 5: —É—á–µ—Ç –∫–æ–º–∏—Å—Å–∏–π –≤ PnL, —à–∞–≥ 6: –ø–µ—Ä–µ—Ö–æ–¥ –Ω–∞ JSON –¥–ª—è TP-–æ–ø—Ç–∏–º–∏–∑–∞—Ç–æ—Ä–∞, –ø–ª—é—Å –º–µ–ª–∫–∏–µ —É–ª—É—á—à–µ–Ω–∏—è) —Ä–µ–∞–ª–∏–∑—É–µ–º—ã —Å –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–º–∏ —Ä–∏—Å–∫–∞–º–∏ –ø—Ä–∏ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ–º –≤–Ω–µ–¥—Ä–µ–Ω–∏–∏ –∏ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–∏.
–ö–∞–∂–µ—Ç—Å—è –≤–µ—Ä–æ—è—Ç–Ω—ã–º, —á—Ç–æ –∏–∑–º–µ–Ω–µ–Ω–∏—è —É–ª—É—á—à–∞—Ç –º–æ–¥—É–ª—å–Ω–æ—Å—Ç—å, –æ—Ç–ª–∞–¥–∫—É –∏ –≥–∏–±–∫–æ—Å—Ç—å —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏, —Å–æ—Ö—Ä–∞–Ω—è—è —Ç–µ–∫—É—â—É—é —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç—å –±–æ—Ç–∞ (v1.6.4).
–î–æ–∫–∞–∑–∞—Ç–µ–ª—å—Å—Ç–≤–∞ —Å–∫–ª–æ–Ω—è—é—Ç—Å—è –∫ —Ç–æ–º—É, —á—Ç–æ —à–∞–≥–∏ –º–æ–∂–Ω–æ –≤–Ω–µ–¥—Ä–∏—Ç—å –∑–∞ 1-2 –Ω–µ–¥–µ–ª–∏, –Ω–∞—á–∏–Ω–∞—è —Å –Ω–∏–∑–∫–æ—Ä–∏—Å–∫–æ–≤—ã—Ö –∏–∑–º–µ–Ω–µ–Ω–∏–π, —Å –ø–æ—Å–ª–µ–¥—É—é—â–∏–º —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ–º –≤ DRY_RUN.
–§–∏–Ω–∞–ª—å–Ω—ã–π –ø–ª–∞–Ω –≤–Ω–µ–¥—Ä–µ–Ω–∏—è —à–∞–≥–æ–≤ 3-6 –∏ –º–µ–ª–∫–∏—Ö —É–ª—É—á—à–µ–Ω–∏–π
–û–±–∑–æ—Ä
–ü–ª–∞–Ω –≤–∫–ª—é—á–∞–µ—Ç –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ–µ –≤–Ω–µ–¥—Ä–µ–Ω–∏–µ —à–∞–≥–æ–≤ 3-6 –∏–∑ Roadmap v1.6.4, –∞ —Ç–∞–∫–∂–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–Ω—ã–µ –º–µ–ª–∫–∏–µ –¥–æ—Ä–∞–±–æ—Ç–∫–∏ (–ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ get_market_regime(), –æ—Ç–ª–∞–¥–æ—á–Ω—ã–µ –ª–æ–≥–∏, –Ω–∞—Å—Ç—Ä–æ–π–∫–∞ TP2). –ö–∞–∂–¥—ã–π —à–∞–≥ —Å–æ–ø—Ä–æ–≤–æ–∂–¥–∞–µ—Ç—Å—è –ø–æ–ª–Ω—ã–º –∫–æ–¥–æ–º, –ø–æ—è—Å–Ω–µ–Ω–∏—è–º–∏ –∏ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è–º–∏ –ø–æ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—é. –¶–µ–ª—å ‚Äî —É–ª—É—á—à–∏—Ç—å –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—é –∫–æ–¥–∞, –æ—Ç–ª–∞–¥–∫—É –∏ –≥–∏–±–∫–æ—Å—Ç—å —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏, –º–∏–Ω–∏–º–∏–∑–∏—Ä—É—è —Ä–∏—Å–∫–∏.

–û–±—â–∏–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏
–ü–æ—Ä—è–¥–æ–∫ –≤–Ω–µ–¥—Ä–µ–Ω–∏—è: –ù–∞—á–∏–Ω–∞–π—Ç–µ —Å –Ω–∏–∑–∫–æ—Ä–∏—Å–∫–æ–≤—ã—Ö —à–∞–≥–æ–≤ (3, 6, –º–µ–ª–∫–∏–µ —É–ª—É—á—à–µ–Ω–∏—è), –∑–∞—Ç–µ–º –ø–µ—Ä–µ—Ö–æ–¥–∏—Ç–µ –∫ —à–∞–≥–∞–º 4 –∏ 5, –∑–∞–≤–µ—Ä—à–∞—è —Å—Ç—Ä–∞—Ç–µ–≥–∏—á–µ—Å–∫–æ–π –¥–æ—Ä–∞–±–æ—Ç–∫–æ–π (TP2).
–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ: –ü–æ—Å–ª–µ –∫–∞–∂–¥–æ–≥–æ —à–∞–≥–∞ –∑–∞–ø—É—Å–∫–∞–π—Ç–µ –±–æ—Ç –≤ DRY_RUN=True –º–∏–Ω–∏–º—É–º 1-2 –¥–Ω—è, –ø—Ä–æ–≤–µ—Ä—è—è –ª–æ–≥–∏ –∏ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å.
–†–µ–∑–µ—Ä–≤–Ω–æ–µ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ: –°–æ—Ö—Ä–∞–Ω–∏—Ç–µ —Ç–µ–∫—É—â—É—é –≤–µ—Ä—Å–∏—é –∫–æ–¥–∞ –ø–µ—Ä–µ–¥ –≤–Ω–µ—Å–µ–Ω–∏–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏–π.
–ü–æ—à–∞–≥–æ–≤—ã–π –ø–ª–∞–Ω —Å –∫–æ–¥–æ–º –∏ –ø–æ—è—Å–Ω–µ–Ω–∏—è–º–∏
–®–∞–≥ 1: –ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ get_market_regime() –≤ volatility_tools.py (–ú–µ–ª–∫–æ–µ —É–ª—É—á—à–µ–Ω–∏–µ)
–û–ø–∏—Å–∞–Ω–∏–µ:

–ü–µ—Ä–µ–º–µ—â–∞–µ–º —Ñ—É–Ω–∫—Ü–∏—é get_market_regime() –∏–∑ trade_engine.py –≤ –Ω–æ–≤—ã–π –º–æ–¥—É–ª—å volatility_tools.py, —á—Ç–æ–±—ã —É–ª—É—á—à–∏—Ç—å –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—é –∫–æ–¥–∞ –∏ —É–ø—Ä–æ—Å—Ç–∏—Ç—å –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ.

–ö–æ–¥:

–°–æ–∑–¥–∞–Ω–∏–µ volatility_tools.py:
python

Copy

# volatility_tools.py

import pandas as pd
import ta
from utils_logging import log
from config import ADX_FLAT_THRESHOLD, ADX_TREND_THRESHOLD

def get_market_regime(symbol, exchange):
try:
ohlcv = exchange.fetch_ohlcv(symbol, timeframe="15m", limit=50)
if len(ohlcv) < 14:
return "neutral", 1.0

        highs = [c[2] for c in ohlcv]
        lows = [c[3] for c in ohlcv]
        closes = [c[4] for c in ohlcv]
        df = pd.DataFrame({"high": highs, "low": lows, "close": closes})
        adx = ta.trend.ADXIndicator(df["high"], df["low"], df["close"], window=14).adx().iloc[-1]

        if adx > ADX_TREND_THRESHOLD:
            regime = "trend"
            scaling_factor = min(adx / 50, 1.5)
        elif adx < ADX_FLAT_THRESHOLD:
            regime = "flat"
            scaling_factor = max(0.5, 1 - (ADX_FLAT_THRESHOLD - adx) / ADX_FLAT_THRESHOLD)
        else:
            regime = "neutral"
            scaling_factor = 1.0
        return regime, scaling_factor
    except Exception as e:
        log(f"Failed to determine market regime for {symbol}: {e}", level="ERROR")
        return "neutral", 1.0

–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ trade_engine.py:
–£–¥–∞–ª—è–µ–º get_market_regime() –∏ –æ–±–Ω–æ–≤–ª—è–µ–º –∏–º–ø–æ—Ä—Ç—ã.
python

Copy

# trade_engine.py

import threading
import time

import pandas as pd
import ta

from config import (
ADX_FLAT_THRESHOLD,
ADX_TREND_THRESHOLD,
AGGRESSIVENESS_THRESHOLD,
AUTO_TP_SL_ENABLED,
BREAKEVEN_TRIGGER,
DRY_RUN,
ENABLE_BREAKEVEN,
ENABLE_TRAILING,
MIN_NOTIONAL,
SL_PERCENT,
SOFT_EXIT_ENABLED,
SOFT_EXIT_SHARE,
SOFT_EXIT_THRESHOLD,
TAKER_FEE_RATE,
TP1_PERCENT,
TP2_PERCENT,
exchange,
)
from core.aggressiveness_controller import get_aggressiveness_score
from core.tp_utils import calculate_tp_levels
from volatility_tools import get_market_regime # –ù–æ–≤—ã–π –∏–º–ø–æ—Ä—Ç
from telegram.telegram_utils import send_telegram_message
from tp_logger import log_trade_result
from utils_core import get_cached_positions, load_state, safe_call_retry
from utils_logging import log, now

# ... (—É–¥–∞–ª—è–µ–º get_market_regime)

def enter_trade(symbol, side, qty, score=5, is_reentry=False): # ... (–ø—Ä–µ–¥—ã–¥—É—â–∏–π –∫–æ–¥)
regime, scaling_factor = get_market_regime(symbol, exchange) # ... (–æ—Å—Ç–∞–ª—å–Ω–æ–π –∫–æ–¥)
–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ strategy.py:
–û–±–Ω–æ–≤–ª—è–µ–º –∏–º–ø–æ—Ä—Ç get_market_regime.
python

Copy

# strategy.py

import threading
from datetime import datetime

import pandas as pd
import ta

from config import (
AUTO_TP_SL_ENABLED,
DRY_RUN,
FILTER_THRESHOLDS,
LEVERAGE_MAP,
SL_PERCENT,
TAKER_FEE_RATE,
VOLATILITY_ATR_THRESHOLD,
VOLATILITY_RANGE_THRESHOLD,
VOLATILITY_SKIP_ENABLED,
exchange,
get_min_net_profit,
)
from core.order_utils import calculate_order_quantity
from core.score_evaluator import calculate_score, get_adaptive_min_score
from core.score_logger import log_score_history
from core.trade_engine import get_position_size, trade_manager
from core.tp_utils import calculate_tp_levels
from core.volatility_controller import get_volatility_filters
from volatility_tools import get_market_regime # –ù–æ–≤—ã–π –∏–º–ø–æ—Ä—Ç
from telegram.telegram_utils import send_telegram_message
from tp_logger import get_trade_stats
from utils_core import get_adaptive_risk_percent, get_cached_balance, safe_call_retry
from utils_logging import log

# ... (–æ—Å—Ç–∞–ª—å–Ω–æ–π –∫–æ–¥)

–ü–æ—è—Å–Ω–µ–Ω–∏–µ:

–ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏ —É–ª—É—á—à–∞–µ—Ç –º–æ–¥—É–ª—å–Ω–æ—Å—Ç—å, –¥–µ–ª–∞—è –∫–æ–¥ –±–æ–ª–µ–µ –æ—Ä–≥–∞–Ω–∏–∑–æ–≤–∞–Ω–Ω—ã–º. –≠—Ç–æ —Ç–∞–∫–∂–µ —É–ø—Ä–æ—â–∞–µ—Ç –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –Ω–æ–≤—ã—Ö —Ñ—É–Ω–∫—Ü–∏–π, —Å–≤—è–∑–∞–Ω–Ω—ã—Ö —Å –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å—é, –≤ –±—É–¥—É—â–µ–º.

–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ:

–ü—Ä–æ–≤–µ—Ä—å—Ç–µ, —á—Ç–æ regime –∏ scaling_factor –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ –æ–ø—Ä–µ–¥–µ–ª—è—é—Ç—Å—è –≤ DRY_RUN.
–£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ TP/SL –º–∞—Å—à—Ç–∞–±–∏—Ä—É—é—Ç—Å—è —Ç–∞–∫ –∂–µ, –∫–∞–∫ —Ä–∞–Ω—å—à–µ.
–†–∏—Å–∫–∏: –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ. –í–æ–∑–º–æ–∂–Ω—ã –æ—à–∏–±–∫–∏ –≤ –∏–º–ø–æ—Ä—Ç–∞—Ö, –Ω–æ –ª–µ–≥–∫–æ –∏—Å–ø—Ä–∞–≤–ª—è—é—Ç—Å—è.

–®–∞–≥ 2: –û–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ last_trade_times –≤ TradeInfoManager (–®–∞–≥ 3)
–û–ø–∏—Å–∞–Ω–∏–µ:

–ü–µ—Ä–µ–Ω–æ—Å–∏–º —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ last_trade_times –∏–∑ strategy.py –≤ TradeInfoManager, —á—Ç–æ–±—ã —Ü–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞—Ç—å –ª–æ–≥–∏–∫—É Smart Re-entry.

–ö–æ–¥:

–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ TradeInfoManager –≤ trade_engine.py:
–î–æ–±–∞–≤–ª—è–µ–º –º–µ—Ç–æ–¥—ã –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å last_trade_times.
python

Copy

# trade_engine.py

class TradeInfoManager:
def **init**(self):
self.\_trades = {}
self.\_last_trade_times = {} # –ù–æ–≤—ã–π —Å–ª–æ–≤–∞—Ä—å
self.\_lock = threading.Lock()

    def add_trade(self, symbol, trade_data):
        with self._lock:
            self._trades[symbol] = trade_data

    def get_trade(self, symbol):
        with self._lock:
            return self._trades.get(symbol)

    def update_trade(self, symbol, key, value):
        with self._lock:
            if symbol in self._trades:
                self._trades[symbol][key] = value

    def remove_trade(self, symbol):
        with self._lock:
            return self._trades.pop(symbol, None)

    def get_last_score(self, symbol):
        with self._lock:
            return self._trades.get(symbol, {}).get("score", 0)

    def get_last_closed_time(self, symbol):
        with self._lock:
            return self._trades.get(symbol, {}).get("last_closed_time", None)

    def set_last_closed_time(self, symbol, timestamp):
        with self._lock:
            if symbol not in self._trades:
                self._trades[symbol] = {}
            self._trades[symbol]["last_closed_time"] = timestamp

    def set_last_trade_time(self, symbol, timestamp):
        with self._lock:
            self._last_trade_times[symbol] = timestamp

    def get_last_trade_time(self, symbol):
        with self._lock:
            return self._last_trade_times.get(symbol)

–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ strategy.py:
–£–¥–∞–ª—è–µ–º last_trade_times –∏ –∏—Å–ø–æ–ª—å–∑—É–µ–º trade_manager.
python

Copy

# strategy.py

import threading
from datetime import datetime

import pandas as pd
import ta

from config import (
AUTO_TP_SL_ENABLED,
DRY_RUN,
FILTER_THRESHOLDS,
LEVERAGE_MAP,
SL_PERCENT,
TAKER_FEE_RATE,
VOLATILITY_ATR_THRESHOLD,
VOLATILITY_RANGE_THRESHOLD,
VOLATILITY_SKIP_ENABLED,
exchange,
get_min_net_profit,
)
from core.order_utils import calculate_order_quantity
from core.score_evaluator import calculate_score, get_adaptive_min_score
from core.score_logger import log_score_history
from core.trade_engine import get_position_size, trade_manager
from core.tp_utils import calculate_tp_levels
from core.volatility_controller import get_volatility_filters
from volatility_tools import get_market_regime
from telegram.telegram_utils import send_telegram_message
from tp_logger import get_trade_stats
from utils_core import get_adaptive_risk_percent, get_cached_balance, safe_call_retry
from utils_logging import log

last_trade_times_lock = threading.Lock()

def fetch_data(symbol, tf="15m"):
try:
data = safe_call_retry(
exchange.fetch_ohlcv, symbol, timeframe=tf, limit=50, label=f"fetch_ohlcv {symbol}"
)
if not data:
log(f"No data returned for {symbol} on timeframe {tf}", level="ERROR")
return None
df = pd.DataFrame(
data,
columns=["time", "open", "high", "low", "close", "volume"],
)
if df.empty:
log(f"Empty DataFrame for {symbol} on timeframe {tf}", level="ERROR")
return None
if len(df) < 14:
log(f"Not enough data for {symbol} on timeframe {tf} (rows: {len(df)})", level="ERROR")
return None
df["rsi"] = ta.momentum.RSIIndicator(df["close"], window=14).rsi()
df["ema"] = ta.trend.EMAIndicator(df["close"], window=20).ema_indicator()
df["macd"] = ta.trend.MACD(df["close"]).macd()
df["macd_signal"] = ta.trend.MACD(df["close"]).macd_signal()
df["atr"] = ta.volatility.AverageTrueRange(
df["high"], df["low"], df["close"], window=14
).average_true_range()
df["fast_ema"] = ta.trend.EMAIndicator(df["close"], window=9).ema_indicator()
df["slow_ema"] = ta.trend.EMAIndicator(df["close"], window=21).ema_indicator()
df["adx"] = ta.trend.ADXIndicator(df["high"], df["low"], df["close"], window=14).adx()
bb = ta.volatility.BollingerBands(df["close"], window=20)
df["bb_width"] = bb.bollinger_hband() - bb.bollinger_lband()
return df
except Exception as e:
log(f"Error fetching data for {symbol}: {e}", level="ERROR")
return None

def get_htf_trend(symbol, tf="1h"):
df_htf = fetch_data(symbol, tf=tf)
if df_htf is None:
return False
return df_htf["close"].iloc[-1] > df_htf["ema"].iloc[-1]

def passes_filters(df, symbol):
balance = get_cached_balance()
filter_mode = "default_light" if balance < 100 else "default"
base_filters = FILTER_THRESHOLDS.get(symbol, FILTER_THRESHOLDS[filter_mode])

    filters = get_volatility_filters(symbol, base_filters)
    relax_factor = filters["relax_factor"]

    if DRY_RUN:
        filters["atr"] *= 0.6
        filters["adx"] *= 0.6
        filters["bb"] *= 0.6

    price = df["close"].iloc[-1]
    atr = df["atr"].iloc[-1] / price
    adx = df["adx"].iloc[-1]
    bb_width = df["bb_width"].iloc[-1] / price

    if atr < filters["atr"]:
        log(
            f"{symbol} ‚õîÔ∏è Rejected: ATR {atr:.5f} < {filters['atr']} (relax={relax_factor})",
            level="DEBUG",
        )
        return False
    if adx < filters["adx"]:
        log(
            f"{symbol} ‚õîÔ∏è Rejected: ADX {adx:.2f} < {filters['adx']} (relax={relax_factor})",
            level="DEBUG",
        )
        return False
    if bb_width < filters["bb"]:
        log(
            f"{symbol} ‚õîÔ∏è Rejected: BB Width {bb_width:.5f} < {filters['bb']} (relax={relax_factor})",
            level="DEBUG",
        )
        return False
    return True

def should_enter_trade(symbol, df, exchange, last_trade_times_lock):
if df is None:
log(f"Skipping {symbol} due to data fetch error", level="WARNING")
return None

    utc_now = datetime.utcnow()
    balance = get_cached_balance()
    position_size = get_position_size(symbol)
    has_long_position = position_size > 0
    has_short_position = position_size < 0
    available_margin = balance * 0.1

    with last_trade_times_lock:
        last_time = trade_manager.get_last_trade_time(symbol)
        cooldown = 30 * 60  # 30 –º–∏–Ω—É—Ç
        elapsed = utc_now.timestamp() - last_time.timestamp() if last_time else float("inf")
        if elapsed < cooldown:
            if DRY_RUN:
                log(f"{symbol} ‚è≥ Ignored due to cooldown")
            return None

    if VOLATILITY_SKIP_ENABLED:
        price = df["close"].iloc[-1]
        high = df["high"].iloc[-1]
        low = df["low"].iloc[-1]
        atr = df["atr"].iloc[-1] / price
        range_ratio = (high - low) / price
        if atr < VOLATILITY_ATR_THRESHOLD and range_ratio < VOLATILITY_RANGE_THRESHOLD:
            if DRY_RUN:
                log(
                    f"{symbol} ‚õîÔ∏è Rejected: low volatility (ATR: {atr:.5f}, Range: {range_ratio:.5f})"
                )
            return None

    if not passes_filters(df, symbol):
        return None

    trade_count, winrate = get_trade_stats()
    score = calculate_score(df, symbol, trade_count, winrate)
    min_required = get_adaptive_min_score(trade_count, winrate)

    if DRY_RUN:
        min_required *= 0.3
        log(f"{symbol} üîé Final Score: {score:.2f} / (Required: {min_required:.4f})")

    if has_long_position or has_short_position or available_margin < 10:
        score -= 0.5

    direction = "BUY" if df["macd"].iloc[-1] > df["macd_signal"].iloc[-1] else "SELL"

    # –ü—Ä–æ–≤–µ—Ä–∫–∞ —á–∏—Å—Ç–æ–π –ø—Ä–∏–±—ã–ª–∏
    entry_price = df["close"].iloc[-1]
    stop_price = (
        entry_price * (1 - SL_PERCENT) if direction == "BUY" else entry_price * (1 + SL_PERCENT)
    )
    risk_percent = get_adaptive_risk_percent(balance)
    qty = calculate_order_quantity(entry_price, stop_price, balance, risk_percent)

    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–æ–º–∏–Ω–∞–ª—å–Ω–æ–π —Å—Ç–æ–∏–º–æ—Å—Ç–∏ —Å —É—á–µ—Ç–æ–º –ø–ª–µ—á–∞
    leverage = LEVERAGE_MAP.get(symbol, 5)
    max_notional = balance * leverage
    notional = qty * entry_price
    if notional > max_notional:
        log(
            f"{symbol} ‚õîÔ∏è Rejected: Notional {notional:.2f} exceeds max {max_notional:.2f} with leverage {leverage}x (balance: {balance:.2f})",
            level="DEBUG",
        )
        return None

    # –†–∞—Å—á–µ—Ç —á–∏—Å—Ç–æ–π –ø—Ä–∏–±—ã–ª–∏ –Ω–∞ TP1
    regime, scaling_factor = get_market_regime(symbol, exchange) if AUTO_TP_SL_ENABLED else (None, 1.0)
    tp1_price, _, _, qty_tp1_share, _ = calculate_tp_levels(entry_price, direction, symbol, regime, score, scaling_factor)

    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –Ω—É–ª–µ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ qty_tp1_share
    if qty_tp1_share == 0:
        log(f"{symbol} ‚õîÔ∏è Rejected: qty_tp1_share is 0", level="DEBUG")
        return None

    qty_tp1 = qty * qty_tp1_share
    gross_profit_tp1 = qty_tp1 * abs(tp1_price - entry_price)
    commission = 2 * (qty * entry_price * TAKER_FEE_RATE)
    net_profit_tp1 = gross_profit_tp1 - commission

    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–≥–æ –ø–æ—Ä–æ–≥–∞ –ø—Ä–∏–±—ã–ª–∏
    min_target_pnl = get_min_net_profit(balance)
    log(
        f"[{symbol}] Qty={qty:.4f}, Entry={entry_price:.4f}, TP1={tp1_price:.4f}, ExpPnl=${net_profit_tp1:.3f}, Min=${min_target_pnl:.3f}",
        level="DEBUG",
    )
    if net_profit_tp1 < min_target_pnl:
        log(
            f"‚ö†Ô∏è Skipping {symbol} ‚Äî expected PnL ${net_profit_tp1:.2f} < min ${min_target_pnl:.2f}",
            level="DEBUG",
        )
        return None

    # Smart Re-entry Logic
    with last_trade_times_lock:
        last_time = trade_manager.get_last_trade_time(symbol)
        now = utc_now.timestamp()
        elapsed = now - last_time.timestamp() if last_time else float("inf")

        last_closed_time = trade_manager.get_last_closed_time(symbol)
        closed_elapsed = now - last_closed_time if last_closed_time else float("inf")
        last_score = trade_manager.get_last_score(symbol)

        if (elapsed < cooldown or closed_elapsed < cooldown) and position_size == 0:
            if score <= 4:
                log(f"Skipping {symbol}: cooldown active, score {score:.2f} <= 4", level="DEBUG")
                return None
            direction = "BUY" if df["macd"].iloc[-1] > df["macd_signal"].iloc[-1] else "SELL"
            log(
                f"{symbol} üîç Generated signal: {direction}, MACD: {df['macd'].iloc[-1]:.5f}, Signal: {df['macd_signal'].iloc[-1]:.5f}",
                level="DEBUG",
            )
            trade_manager.set_last_trade_time(symbol, utc_now)
            if not DRY_RUN:
                log_score_history(symbol, score)
                log(f"{symbol} ‚úÖ Re-entry {direction} signal triggered (score: {score:.2f}/5)")
            else:
                msg = f"üß™-DRY-RUN-REENTRY-{symbol}-{direction}-Score-{score:.2f}-of-5"
                send_telegram_message(msg, force=True, parse_mode="")
            return ("buy" if direction == "BUY" else "sell", score, True)

        if last_score and score - last_score >= 1.5 and position_size == 0:
            direction = "BUY" if df["macd"].iloc[-1] > df["macd_signal"].iloc[-1] else "SELL"
            log(
                f"{symbol} üîç Generated signal: {direction}, MACD: {df['macd'].iloc[-1]:.5f}, Signal: {df['macd_signal'].iloc[-1]:.5f}",
                level="DEBUG",
            )
            trade_manager.set_last_trade_time(symbol, utc_now)
            if not DRY_RUN:
                log_score_history(symbol, score)
                log(f"{symbol} ‚úÖ Re-entry {direction} signal triggered (score: {score:.2f}/5)")
            else:
                msg = f"üß™-DRY-RUN-REENTRY-{symbol}-{direction}-Score-{score:.2f}-of-5"
                send_telegram_message(msg, force=True, parse_mode="")
            return ("buy" if direction == "BUY" else "sell", score, True)

        # –û–±—ã—á–Ω—ã–π –≤—Ö–æ–¥
        if score < min_required:
            if DRY_RUN:
                log(
                    f"{symbol} ‚ùå No entry: insufficient score\n"
                    f"Final Score: {score:.2f} / (Required: {min_required:.4f})"
                )
            return None

    with last_trade_times_lock:
        trade_manager.set_last_trade_time(symbol, utc_now)

    direction = "BUY" if df["macd"].iloc[-1] > df["macd_signal"].iloc[-1] else "SELL"
    log(
        f"{symbol} üîç Generated signal: {direction}, MACD: {df['macd'].iloc[-1]:.5f}, Signal: {df['macd_signal'].iloc[-1]:.5f}",
        level="DEBUG",
    )
    if not DRY_RUN:
        log_score_history(symbol, score)
        log(f"{symbol} ‚úÖ {direction} signal triggered (score: {score:.2f}/5)")
    else:
        msg = f"üß™-DRY-RUN-{symbol}-{direction}-Score-{score:.2f}-of-5"
        send_telegram_message(msg, force=True, parse_mode="")

    return ("buy" if direction == "BUY" else "sell", score, False)

–ü–æ—è—Å–Ω–µ–Ω–∏–µ:

–¶–µ–Ω—Ç—Ä–∞–ª–∏–∑–∞—Ü–∏—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –≤—Ä–µ–º–µ–Ω–µ–º —Å–¥–µ–ª–æ–∫ –≤ TradeInfoManager —É–ø—Ä–æ—â–∞–µ—Ç –∫–æ–¥, —Å–Ω–∏–∂–∞—è —Ä–∏—Å–∫ —Ä–∞—Å—Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏. –ü–æ—Ç–æ–∫–æ–±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å –æ–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç—Å—è —á–µ—Ä–µ–∑ Lock.

–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ:

–ü—Ä–æ–≤–µ—Ä—å—Ç–µ, —á—Ç–æ Smart Re-entry —Ä–∞–±–æ—Ç–∞–µ—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ: cooldown (30 –º–∏–Ω—É—Ç) —Å–æ–±–ª—é–¥–∞–µ—Ç—Å—è, –ø–æ–≤—Ç–æ—Ä–Ω—ã–π –≤—Ö–æ–¥ —Å—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –ø—Ä–∏ score > 4 –∏–ª–∏ —Ä–æ—Å—Ç–µ —Å–∫–æ—Ä–∞ –Ω–∞ 1.5.
–£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –ª–æ–≥–∏ –æ—Ç—Ä–∞–∂–∞—é—Ç –ø—Ä–∞–≤–∏–ª—å–Ω—ã–µ –≤—Ä–µ–º–µ–Ω–Ω—ã–µ –º–µ—Ç–∫–∏.
–†–∏—Å–∫–∏: –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ, —Ç–∞–∫ –∫–∞–∫ —ç—Ç–æ —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥ –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏—è –ª–æ–≥–∏–∫–∏.

–®–∞–≥ 3: –ú–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ TP/SL –ø–æ —Ç—Ä–µ–Ω–¥—É (–®–∞–≥ 4)
–û–ø–∏—Å–∞–Ω–∏–µ:

–£–ª—É—á—à–∞–µ–º –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ TP/SL, –∏—Å–ø–æ–ª—å–∑—É—è scaling_factor –∏–∑ get_market_regime() –¥–ª—è –∞–¥–∞–ø—Ç–∞—Ü–∏–∏ –∫ —Å–∏–ª–µ —Ç—Ä–µ–Ω–¥–∞.

–ö–æ–¥:

–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ tp_utils.py:
–£—á–∏—Ç—ã–≤–∞–µ–º scaling_factor –ø—Ä–∏ —Ä–∞—Å—á–µ—Ç–µ TP/SL.
python

Copy

# tp_utils.py

import json
from config import AUTO_TP_SL_ENABLED, FLAT_ADJUSTMENT, SL_PERCENT, TP1_PERCENT, TP2_PERCENT, TP1_SHARE, TP2_SHARE, TREND_ADJUSTMENT, CONFIG_DYNAMIC_FILE
from utils_logging import log

def calculate_tp_levels(entry_price: float, side: str, symbol: str, regime: str = None, score: float = 5, scaling_factor: float = 1.0, atr: float = None, price: float = None):
"""
–í—ã—á–∏—Å–ª—è–µ—Ç —Ü–µ–Ω—ã TP1, TP2 –∏ SL –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ü–µ–Ω—ã –≤—Ö–æ–¥–∞, —Å—Ç–æ—Ä–æ–Ω—ã, —Ä–µ–∂–∏–º–∞ —Ä—ã–Ω–∫–∞ –∏ –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç–∏ (ATR).
"""
try:
with open(CONFIG_DYNAMIC_FILE, "r") as f:
config_data = json.load(f)
if symbol in config_data:
tp1_pct = config_data[symbol]["tp1"]
tp2_pct = config_data[symbol]["tp2"]
log(f"{symbol} using TP1={tp1_pct}, TP2={tp2_pct} (source: dynamic)", level="DEBUG")
else:
tp1_pct = TP1_PERCENT
tp2_pct = TP2_PERCENT
log(f"{symbol} using TP1={tp1_pct}, TP2={tp2_pct} (source: default)", level="DEBUG")
except Exception as e:
log(f"Failed to load dynamic config for {symbol}: {e}", level="WARNING")
tp1_pct = TP1_PERCENT
tp2_pct = TP2_PERCENT
log(f"{symbol} using TP1={tp1_pct}, TP2={tp2_pct} (source: default, error)", level="DEBUG")

    # –ê–¥–∞–ø—Ç–∞—Ü–∏—è SL –Ω–∞ –æ—Å–Ω–æ–≤–µ ATR (–µ—Å–ª–∏ –ø–µ—Ä–µ–¥–∞–Ω–æ)
    sl_pct = SL_PERCENT
    if atr is not None and price is not None:
        atr_ratio = atr / price
        if atr_ratio > 0.002:
            sl_pct *= 1.5
        elif atr_ratio < 0.001:
            sl_pct *= 0.5

    # –ú–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ TP/SL –ø–æ —Ç—Ä–µ–Ω–¥—É
    tp1_pct *= scaling_factor
    tp2_pct = tp2_pct * scaling_factor if tp2_pct else None
    sl_pct *= scaling_factor

    if AUTO_TP_SL_ENABLED and regime:
        if regime == "flat":
            tp1_pct *= FLAT_ADJUSTMENT
            tp2_pct = tp2_pct * FLAT_ADJUSTMENT if tp2_pct else None
            sl_pct *= FLAT_ADJUSTMENT
        elif regime == "trend":
            tp2_pct = tp2_pct * TREND_ADJUSTMENT if tp2_pct else None
            sl_pct *= TREND_ADJUSTMENT

    if score == 3:
        tp1_pct *= 0.8
        tp2_pct = None
        sl_pct *= 0.8

    if side.lower() == "buy":
        tp1_price = entry_price * (1 + tp1_pct)
        tp2_price = entry_price * (1 + tp2_pct) if tp2_pct else None
        sl_price = entry_price * (1 - sl_pct)
    else:  # side == "sell"
        tp1_price = entry_price * (1 - tp1_pct)
        tp2_price = entry_price * (1 - tp2_pct) if tp2_pct else None
        sl_price = entry_price * (1 + sl_pct)

    qty_tp1 = TP1_SHARE
    qty_tp2 = TP2_SHARE if tp2_price else 0

    return round(tp1_price, 4), round(tp2_price, 4) if tp2_price else None, round(sl_price, 4), qty_tp1, qty_tp2

–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤—ã–∑–æ–≤–æ–≤ –≤ strategy.py –∏ trade_engine.py:
–£–∂–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ —Ä–∞–Ω–µ–µ (–ø–µ—Ä–µ–¥–∞–µ–º scaling_factor).
–ü–æ—è—Å–Ω–µ–Ω–∏–µ:

–ú–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ TP/SL –ø–æ —Å–∏–ª–µ —Ç—Ä–µ–Ω–¥–∞ –¥–µ–ª–∞–µ—Ç —Å—Ç—Ä–∞—Ç–µ–≥–∏—é –±–æ–ª–µ–µ –≥–∏–±–∫–æ–π, —É–≤–µ–ª–∏—á–∏–≤–∞—è TP –≤ —Å–∏–ª—å–Ω—ã—Ö —Ç—Ä–µ–Ω–¥–∞—Ö –∏ —É–º–µ–Ω—å—à–∞—è –≤ —Å–ª–∞–±—ã—Ö, —á—Ç–æ —É–ª—É—á—à–∞–µ—Ç –±–∞–ª–∞–Ω—Å —Ä–∏—Å–∫–∞ –∏ –ø—Ä–∏–±—ã–ª–∏.

–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ:

–ü—Ä–æ–≤–µ—Ä—å—Ç–µ, —á—Ç–æ TP/SL –º–∞—Å—à—Ç–∞–±–∏—Ä—É—é—Ç—Å—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ:
–í —Å–∏–ª—å–Ω—ã—Ö —Ç—Ä–µ–Ω–¥–∞—Ö (ADX > 25) TP/SL —É–≤–µ–ª–∏—á–∏–≤–∞—é—Ç—Å—è (–Ω–∞–ø—Ä–∏–º–µ—Ä, –¥–æ 1,5x).
–í–æ —Ñ–ª–µ—Ç–∞—Ö (ADX < 15) —É–º–µ–Ω—å—à–∞—é—Ç—Å—è (–Ω–∞–ø—Ä–∏–º–µ—Ä, –¥–æ 0,5x).
–£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ —ç—Ç–æ –Ω–µ –ø—Ä–∏–≤–æ–¥–∏—Ç –∫ —á—Ä–µ–∑–º–µ—Ä–Ω—ã–º —É–±—ã—Ç–∫–∞–º (—Å–ª–∏—à–∫–æ–º —à–∏—Ä–æ–∫–∏–π SL) –∏–ª–∏ –ø—Ä–æ–ø—É—Å–∫—É —Ü–µ–ª–µ–π (—Å–ª–∏—à–∫–æ–º —É–∑–∫–∏–π TP).
–†–∏—Å–∫–∏: –ù–∏–∑–∫–∏–µ, –Ω–æ —Ç—Ä–µ–±—É–µ—Ç—Å—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –≤ DRY_RUN (1-2 –¥–Ω—è).

–®–∞–≥ 4: –£—á–µ—Ç –∫–æ–º–∏—Å—Å–∏–π –≤ PnL (–®–∞–≥ 5)
–û–ø–∏—Å–∞–Ω–∏–µ:

–î–æ–±–∞–≤–ª—è–µ–º —É—á–µ—Ç –∫–æ–º–∏—Å—Å–∏–π –≤ —Ä–∞—Å—á–µ—Ç PnL –≤ –ª–æ–≥–∞—Ö –∏ –æ—Ç—á–µ—Ç–∞—Ö –¥–ª—è –±–æ–ª–µ–µ —Ç–æ—á–Ω–æ–π –æ—Ü–µ–Ω–∫–∏ –ø—Ä–∏–±—ã–ª—å–Ω–æ—Å—Ç–∏.

–ö–æ–¥:

–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ tp_logger.py:
–†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —á–∏—Å—Ç—É—é –ø—Ä–∏–±—ã–ª—å —Å —É—á–µ—Ç–æ–º –∫–æ–º–∏—Å—Å–∏–π.
python

Copy

# tp_logger.py

import pandas as pd
from config import TAKER_FEE_RATE
from utils_logging import log

def log_trade_result(trade_data):
symbol = trade_data["symbol"]
side = trade_data["side"]
entry_price = trade_data["entry_price"]
exit_price = trade_data["exit_price"]
qty = trade_data["qty"]
tp1_hit = trade_data["tp1_hit"]
tp2_hit = trade_data["tp2_hit"]
sl_hit = trade_data["sl_hit"]
pnl_percent = trade_data["pnl_percent"]
result = trade_data["result"]
duration_minutes = trade_data["duration_minutes"]
htf_trend = trade_data["htf_trend"]

    # –†–∞—Å—á–µ—Ç —á–∏—Å—Ç–æ–π –ø—Ä–∏–±—ã–ª–∏
    gross_pnl = (exit_price - entry_price) * qty if side == "buy" else (entry_price - exit_price) * qty
    commission = 2 * qty * entry_price * TAKER_FEE_RATE
    net_pnl = gross_pnl - commission
    net_pnl_percent = net_pnl / (entry_price * qty) * 100

    log(
        f"{symbol} Trade Result: {result}, Gross PnL: {gross_pnl:.2f} USDC, Net PnL: {net_pnl:.2f} USDC ({net_pnl_percent:.2f}%), Duration: {duration_minutes} min",
        level="INFO"
    )

    # –ó–∞–ø–∏—Å—å –≤ CSV
    trade_record = {
        "Date": pd.Timestamp.now(),
        "Symbol": symbol,
        "Side": side,
        "EntryPrice": entry_price,
        "ExitPrice": exit_price,
        "Qty": qty,
        "GrossPnL": gross_pnl,
        "NetPnL": net_pnl,
        "NetPnLPercent": net_pnl_percent,
        "Result": result,
        "DurationMinutes": duration_minutes,
        "TP1Hit": tp1_hit,
        "TP2Hit": tp2_hit,
        "SLHit": sl_hit,
        "HTFTrend": htf_trend
    }

    df = pd.DataFrame([trade_record])
    df.to_csv("data/tp_performance.csv", mode="a", header=not pd.io.common.file_exists("data/tp_performance.csv"), index=False)

–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ trade_engine.py:
–ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º record_trade_result –¥–ª—è —É—á–µ—Ç–∞ –∫–æ–º–∏—Å—Å–∏–π.
python

Copy

# trade_engine.py

def record_trade_result(symbol, side, entry_price, exit_price, result_type):
global open_positions_count, dry_run_positions_count
with open_positions_lock:
if DRY_RUN:
dry_run_positions_count -= 1
else:
open_positions_count -= 1

    trade = trade_manager.get_trade(symbol)
    if not trade:
        log(f"‚ö†Ô∏è No trade info for {symbol} ‚Äî cannot record result")
        return

    qty = trade["qty"]
    duration = int((time.time() - trade["start_time"].timestamp()) / 60)
    gross_pnl = (exit_price - entry_price) / entry_price * 100 if side == "buy" else (entry_price - exit_price) / entry_price * 100
    commission = 2 * qty * entry_price * TAKER_FEE_RATE
    net_pnl = ((exit_price - entry_price) * qty - commission) / (entry_price * qty) * 100 if side == "buy" else ((entry_price - exit_price) * qty - commission) / (entry_price * qty) * 100

    log_trade_result({
        "symbol": symbol,
        "side": side,
        "entry_price": entry_price,
        "exit_price": exit_price,
        "qty": qty,
        "tp1_hit": trade.get("tp1_hit", False),
        "tp2_hit": trade.get("tp2_hit", False),
        "sl_hit": (result_type == "sl"),
        "pnl_percent": net_pnl,  # –ò—Å–ø–æ–ª—å–∑—É–µ–º —á–∏—Å—Ç—É—é –ø—Ä–∏–±—ã–ª—å
        "result": "WIN" if net_pnl > 0 else "LOSS",
        "duration_minutes": duration,
        "htf_trend": trade.get("htf_trend", False),
    })

    msg = (
        f"üì§ *Trade Closed* [{result_type.upper()}{' + Soft Exit' if trade.get('soft_exit_hit', False) else ''}]\n"
        f"‚Ä¢ {symbol} ‚Äî {side.upper()}\n"
        f"‚Ä¢ Entry: {round(entry_price, 4)} ‚Üí Exit: {round(exit_price, 4)}\n"
        f"‚Ä¢ Net PnL: {round(net_pnl, 2)}% | Held: {duration} min"
    )
    send_telegram_message(msg, force=True)

    trade_manager.remove_trade(symbol)

–ü–æ—è—Å–Ω–µ–Ω–∏–µ:

–£—á–µ—Ç –∫–æ–º–∏—Å—Å–∏–π –≤ PnL –¥–∞–µ—Ç –±–æ–ª–µ–µ —Ç–æ—á–Ω—É—é –∫–∞—Ä—Ç–∏–Ω—É –ø—Ä–∏–±—ã–ª—å–Ω–æ—Å—Ç–∏, —á—Ç–æ –≤–∞–∂–Ω–æ –¥–ª—è –æ—Ç—á–µ—Ç–æ–≤ –∏ –±—É–¥—É—â–∏—Ö —É–ª—É—á—à–µ–Ω–∏–π (–Ω–∞–ø—Ä–∏–º–µ—Ä, UI).

–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ:

–ü—Ä–æ–≤–µ—Ä—å—Ç–µ, —á—Ç–æ –ª–æ–≥–∏ –∏ –æ—Ç—á–µ—Ç—ã –ø–æ–∫–∞–∑—ã–≤–∞—é—Ç —á–∏—Å—Ç—É—é –ø—Ä–∏–±—ã–ª—å (Net PnL), –∞ –Ω–µ —Ç–æ–ª—å–∫–æ –≤–∞–ª–æ–≤—É—é.
–£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –∑–Ω–∞—á–µ–Ω–∏—è —Å–æ–≤–ø–∞–¥–∞—é—Ç —Å —Ä–∞—Å—á–µ—Ç–∞–º–∏ (–≤–∞–ª–æ–≤–∞—è –ø—Ä–∏–±—ã–ª—å - –∫–æ–º–∏—Å—Å–∏–∏).
–†–∏—Å–∫–∏: –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ. –≠—Ç–æ —É–ª—É—á—à–µ–Ω–∏–µ –æ—Ç—á–µ—Ç–Ω–æ—Å—Ç–∏, –Ω–µ –∑–∞—Ç—Ä–∞–≥–∏–≤–∞—é—â–µ–µ —Ç–æ—Ä–≥–æ–≤—É—é –ª–æ–≥–∏–∫—É.

–®–∞–≥ 5: –§–∏–∫—Å–∞—Ü–∏—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ TP-–æ–ø—Ç–∏–º–∏–∑–∞—Ç–æ—Ä–∞ (–®–∞–≥ 6)
–û–ø–∏—Å–∞–Ω–∏–µ:

–ü–µ—Ä–µ—Ö–æ–¥–∏–º —Å —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è config.py –Ω–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ config_dynamic.json –≤ tp_optimizer_ml.py –¥–ª—è –Ω–∞–¥–µ–∂–Ω–æ—Å—Ç–∏.

–ö–æ–¥:

–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ config.py:
–î–æ–±–∞–≤–ª—è–µ–º –ø—É—Ç—å –∫ —Ñ–∞–π–ª—É config_dynamic.json.
python

Copy

# config.py

CONFIG_DYNAMIC_FILE = "data/config_dynamic.json"
–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ tp_optimizer_ml.py:
–ü–µ—Ä–µ–∫–ª—é—á–∞–µ–º—Å—è –Ω–∞ JSON.
python

Copy

# tp_optimizer_ml.py

import json
from config import CONFIG_DYNAMIC_FILE
from utils_logging import log

def update_tp_config(symbol, tp1, tp2):
try:
try:
with open(CONFIG_DYNAMIC_FILE, "r") as f:
config_data = json.load(f)
except FileNotFoundError:
config_data = {}

        config_data[symbol] = {"tp1": tp1, "tp2": tp2}

        with open(CONFIG_DYNAMIC_FILE, "w") as f:
            json.dump(config_data, f, indent=4)

        log(f"TP config updated for {symbol}: TP1={tp1}, TP2={tp2}", level="INFO")
    except Exception as e:
        log(f"Failed to update config for {symbol}: {e}", level="ERROR")

–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ tp_utils.py:
–î–æ–±–∞–≤–ª—è–µ–º –æ—Ç–ª–∞–¥–æ—á–Ω—ã–π –ª–æ–≥ (—Å–º. —Å–ª–µ–¥—É—é—â–∏–π —à–∞–≥).
–ü–æ—è—Å–Ω–µ–Ω–∏–µ:

JSON —É–ø—Ä–æ—â–∞–µ—Ç —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º–∏, —Å–Ω–∏–∂–∞—è —Ä–∏—Å–∫ –æ—à–∏–±–æ–∫ –ø–∞—Ä—Å–∏–Ω–≥–∞. –≠—Ç–æ —Ç–∞–∫–∂–µ –¥–µ–ª–∞–µ—Ç —Å–∏—Å—Ç–µ–º—É –±–æ–ª–µ–µ –º–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º–æ–π –¥–ª—è –±—É–¥—É—â–∏—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ (–Ω–∞–ø—Ä–∏–º–µ—Ä, SL).

–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ:

–£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ TP-–æ–ø—Ç–∏–º–∏–∑–∞—Ç–æ—Ä –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ –æ–±–Ω–æ–≤–ª—è–µ—Ç config_dynamic.json.
–ü—Ä–æ–≤–µ—Ä—å—Ç–µ, —á—Ç–æ tp_utils.py —á–∏—Ç–∞–µ—Ç –∑–Ω–∞—á–µ–Ω–∏—è –∏–∑ JSON —Å fallback –Ω–∞ –¥–µ—Ñ–æ–ª—Ç–Ω—ã–µ.
–†–∏—Å–∫–∏: –ù–∏–∑–∫–∏–µ. –¢—Ä–µ–±—É–µ—Ç—Å—è –±–∞–∑–æ–≤–æ–µ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ.

–®–∞–≥ 6: –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –æ—Ç–ª–∞–¥–æ—á–Ω–æ–≥–æ –ª–æ–≥–∞ –≤ tp_utils.py (–ú–µ–ª–∫–æ–µ —É–ª—É—á—à–µ–Ω–∏–µ)
–û–ø–∏—Å–∞–Ω–∏–µ:

–î–æ–±–∞–≤–ª—è–µ–º –æ—Ç–ª–∞–¥–æ—á–Ω—ã–π –ª–æ–≥, —á—Ç–æ–±—ã –≤–∏–¥–µ—Ç—å –∏—Å—Ç–æ—á–Ω–∏–∫ –∑–Ω–∞—á–µ–Ω–∏–π TP (–¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–π –∏–ª–∏ –¥–µ—Ñ–æ–ª—Ç–Ω—ã–π).

–ö–æ–¥:

–û–±–Ω–æ–≤–ª—è–µ–º tp_utils.py (—É–∂–µ —á–∞—Å—Ç–∏—á–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω –≤—ã—à–µ):
python

Copy

# tp_utils.py

import json
from config import AUTO_TP_SL_ENABLED, FLAT_ADJUSTMENT, SL_PERCENT, TP1_PERCENT, TP2_PERCENT, TP1_SHARE, TP2_SHARE, TREND_ADJUSTMENT, CONFIG_DYNAMIC_FILE
from utils_logging import log

def calculate_tp_levels(entry_price: float, side: str, symbol: str, regime: str = None, score: float = 5, scaling_factor: float = 1.0, atr: float = None, price: float = None):
"""
–í—ã—á–∏—Å–ª—è–µ—Ç —Ü–µ–Ω—ã TP1, TP2 –∏ SL –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ü–µ–Ω—ã –≤—Ö–æ–¥–∞, —Å—Ç–æ—Ä–æ–Ω—ã, —Ä–µ–∂–∏–º–∞ —Ä—ã–Ω–∫–∞ –∏ –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç–∏ (ATR).
"""
try:
with open(CONFIG_DYNAMIC_FILE, "r") as f:
config_data = json.load(f)
if symbol in config_data:
tp1_pct = config_data[symbol]["tp1"]
tp2_pct = config_data[symbol]["tp2"]
log(f"{symbol} using TP1={tp1_pct}, TP2={tp2_pct} (source: dynamic)", level="DEBUG")
else:
tp1_pct = TP1_PERCENT
tp2_pct = TP2_PERCENT
log(f"{symbol} using TP1={tp1_pct}, TP2={tp2_pct} (source: default)", level="DEBUG")
except Exception as e:
log(f"Failed to load dynamic config for {symbol}: {e}", level="WARNING")
tp1_pct = TP1_PERCENT
tp2_pct = TP2_PERCENT
log(f"{symbol} using TP1={tp1_pct}, TP2={tp2_pct} (source: default, error)", level="DEBUG")

    # –ê–¥–∞–ø—Ç–∞—Ü–∏—è SL –Ω–∞ –æ—Å–Ω–æ–≤–µ ATR (–µ—Å–ª–∏ –ø–µ—Ä–µ–¥–∞–Ω–æ)
    sl_pct = SL_PERCENT
    if atr is not None and price is not None:
        atr_ratio = atr / price
        if atr_ratio > 0.002:
            sl_pct *= 1.5
        elif atr_ratio < 0.001:
            sl_pct *= 0.5

    # –ú–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ TP/SL –ø–æ —Ç—Ä–µ–Ω–¥—É
    tp1_pct *= scaling_factor
    tp2_pct = tp2_pct * scaling_factor if tp2_pct else None
    sl_pct *= scaling_factor

    if AUTO_TP_SL_ENABLED and regime:
        if regime == "flat":
            tp1_pct *= FLAT_ADJUSTMENT
            tp2_pct = tp2_pct * FLAT_ADJUSTMENT if tp2_pct else None
            sl_pct *= FLAT_ADJUSTMENT
        elif regime == "trend":
            tp2_pct = tp2_pct * TREND_ADJUSTMENT if tp2_pct else None
            sl_pct *= TREND_ADJUSTMENT

    if score == 3:
        tp1_pct *= 0.8
        tp2_pct = None
        sl_pct *= 0.8

    if side.lower() == "buy":
        tp1_price = entry_price * (1 + tp1_pct)
        tp2_price = entry_price * (1 + tp2_pct) if tp2_pct else None
        sl_price = entry_price * (1 - sl_pct)
    else:  # side == "sell"
        tp1_price = entry_price * (1 - tp1_pct)
        tp2_price = entry_price * (1 - tp2_pct) if tp2_pct else None
        sl_price = entry_price * (1 + sl_pct)

    qty_tp1 = TP1_SHARE
    qty_tp2 = TP2_SHARE if tp2_price else 0

    return round(tp1_price, 4), round(tp2_price, 4) if tp2_price else None, round(sl_price, 4), qty_tp1, qty_tp2

–ü–æ—è—Å–Ω–µ–Ω–∏–µ:

–õ–æ–≥–∏ –Ω–∞ —É—Ä–æ–≤–Ω–µ DEBUG –ø–æ–º–æ–≥–∞—é—Ç –æ—Ç—Å–ª–µ–∂–∏–≤–∞—Ç—å, –æ—Ç–∫—É–¥–∞ –±–µ—Ä—É—Ç—Å—è –∑–Ω–∞—á–µ–Ω–∏—è TP (–¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–µ –∏–ª–∏ –¥–µ—Ñ–æ–ª—Ç–Ω—ã–µ), —á—Ç–æ —É–ø—Ä–æ—â–∞–µ—Ç –æ—Ç–ª–∞–¥–∫—É –ø—Ä–æ–±–ª–µ–º —Å –æ–ø—Ç–∏–º–∏–∑–∞—Ç–æ—Ä–æ–º.

–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ:

–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ª–æ–≥–∏ –≤ DRY_RUN —Å LOG_LEVEL="DEBUG".
–£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –∏—Å—Ç–æ—á–Ω–∏–∫–∏ TP (–¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–π –∏–ª–∏ –¥–µ—Ñ–æ–ª—Ç–Ω—ã–π) –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ –æ—Ç–æ–±—Ä–∞–∂–∞—é—Ç—Å—è.
–†–∏—Å–∫–∏: –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ, —Ç–∞–∫ –∫–∞–∫ —ç—Ç–æ –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –ª–æ–≥–æ–≤.

–®–∞–≥ 7: –ù–∞—Å—Ç—Ä–æ–π–∫–∞ TP2 = None –ø—Ä–∏ –Ω–∏–∑–∫–æ–º score (–ú–µ–ª–∫–æ–µ —É–ª—É—á—à–µ–Ω–∏–µ)
–û–ø–∏—Å–∞–Ω–∏–µ:

–£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º TP2 = None –¥–ª—è —Å–ª–∞–±—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤ (score < 3), —á—Ç–æ–±—ã —É–º–µ–Ω—å—à–∏—Ç—å —Ä–∞—Å—Å–µ—è–Ω–∏–µ TP –∏ —Å–æ—Å—Ä–µ–¥–æ—Ç–æ—á–∏—Ç—å—Å—è –Ω–∞ TP1.

–ö–æ–¥:

–û–±–Ω–æ–≤–ª—è–µ–º tp_utils.py:
python

Copy

# tp_utils.py (—Ñ—Ä–∞–≥–º–µ–Ω—Ç)

if score < 3:
tp2_pct = None
log(f"{symbol} TP2 set to None due to low score {score}", level="DEBUG")
–ü–æ—è—Å–Ω–µ–Ω–∏–µ:

–≠—Ç–æ —É–ª—É—á—à–∞–µ—Ç —Å—Ç—Ä–∞—Ç–µ–≥–∏—é, —Å–Ω–∏–∂–∞—è —Ä–∞—Å—Å–µ—è–Ω–∏–µ TP –Ω–∞ —Å–ª–∞–±—ã—Ö —Å–∏–≥–Ω–∞–ª–∞—Ö, —á—Ç–æ –º–æ–∂–µ—Ç –ø–æ–≤—ã—Å–∏—Ç—å –≤–∏–Ω—Ä–µ–π—Ç –∑–∞ —Å—á–µ—Ç —Ñ–∏–∫—Å–∞—Ü–∏–∏ –ø—Ä–∏–±—ã–ª–∏ –Ω–∞ TP1.

–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ:

–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –≤ DRY_RUN, —á—Ç–æ TP2 —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç—Å—è –≤ None –ø—Ä–∏ score < 3.
–°—Ä–∞–≤–Ω–∏—Ç–µ –≤–∏–Ω—Ä–µ–π—Ç –∏ –æ–±—â—É—é –ø—Ä–∏–±—ã–ª—å —Å/–±–µ–∑ —ç—Ç–æ–≥–æ –∏–∑–º–µ–Ω–µ–Ω–∏—è (1-2 –Ω–µ–¥–µ–ª–∏).
–†–∏—Å–∫–∏: –£–º–µ—Ä–µ–Ω–Ω—ã–µ. –ú–æ–∂–µ—Ç —É–º–µ–Ω—å—à–∏—Ç—å –ø—Ä–∏–±—ã–ª—å –æ—Ç —Å–∏–ª—å–Ω—ã—Ö –¥–≤–∏–∂–µ–Ω–∏–π, –µ—Å–ª–∏ TP2 –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è. –¢—Ä–µ–±—É–µ—Ç—Å—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ.

–ó–∞–∫–ª—é—á–µ–Ω–∏–µ
–ü–ª–∞–Ω –≤–∫–ª—é—á–∞–µ—Ç 7 —à–∞–≥–æ–≤:

–ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ get_market_regime() (–Ω–∏–∑–∫–∏–π —Ä–∏—Å–∫).
–û–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ last_trade_times (–Ω–∏–∑–∫–∏–π —Ä–∏—Å–∫).
–ú–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ TP/SL (–Ω–∏–∑–∫–∏–π —Ä–∏—Å–∫).
–£—á–µ—Ç –∫–æ–º–∏—Å—Å–∏–π –≤ PnL (–º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —Ä–∏—Å–∫).
–ü–µ—Ä–µ—Ö–æ–¥ –Ω–∞ JSON –≤ TP-–æ–ø—Ç–∏–º–∏–∑–∞—Ç–æ—Ä–µ (–Ω–∏–∑–∫–∏–π —Ä–∏—Å–∫).
–û—Ç–ª–∞–¥–æ—á–Ω—ã–µ –ª–æ–≥–∏ –≤ tp_utils.py (–º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —Ä–∏—Å–∫).
–ù–∞—Å—Ç—Ä–æ–π–∫–∞ TP2 (—É–º–µ—Ä–µ–Ω–Ω—ã–π —Ä–∏—Å–∫).
–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è:

–í–Ω–µ–¥—Ä—è–π—Ç–µ —à–∞–≥–∏ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ, –Ω–∞—á–∏–Ω–∞—è —Å 1-6 (–Ω–∏–∑–∫–∏–π —Ä–∏—Å–∫), —Ç–µ—Å—Ç–∏—Ä—É—è –∫–∞–∂–¥—ã–π –≤ DRY_RUN.
–®–∞–≥ 7 (TP2) –≤–Ω–µ–¥—Ä—è–π—Ç–µ –ø–æ—Å–ª–µ–¥–Ω–∏–º, —Å –¥–ª–∏—Ç–µ–ª—å–Ω—ã–º —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ–º (1-2 –Ω–µ–¥–µ–ª–∏), —á—Ç–æ–±—ã –æ—Ü–µ–Ω–∏—Ç—å –≤–ª–∏—è–Ω–∏–µ –Ω–∞ –≤–∏–Ω—Ä–µ–π—Ç –∏ –ø—Ä–∏–±—ã–ª—å.
–ü–æ—Å–ª–µ –≤–Ω–µ–¥—Ä–µ–Ω–∏—è –≤—Å–µ—Ö —à–∞–≥–æ–≤ –ø–µ—Ä–µ—Ö–æ–¥–∏—Ç–µ –∫ —Å–ª–µ–¥—É—é—â–µ–º—É –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç—É –∏–∑ Roadmap (–Ω–∞–ø—Ä–∏–º–µ—Ä, WebSocket).
