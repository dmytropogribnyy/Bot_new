Аудит проекта торгового бота
Архитектура проекта
Проект организован модульно, разделяя логику торговли, утилиты, взаимодействие с Telegram и прочее по разным файлам:
Основной модуль (main.py) – Точка входа, запускает фоновые потоки и главный цикл торговли. В главном потоке выполняется функция start_trading_loop(), которая непрерывно перебирает активные торговые пары группами и вызывает цикл торговли. Параллельно main.py запускает:
Поток обработки Telegram-команд (через telegram_handler.process_telegram_commands), позволяющий получать команды пользователя (/stop, /pause и т.д.).
Поток мониторинга IP (ip_monitor.start_ip_monitor), отслеживающий смену внешнего IP и останавливающий бота при изменении (для безопасности API-ключей).
Поток ротации пар (pair_selector.start_symbol_rotation), который раз в час обновляет список торгуемых символов (динамически выбирая самые волатильные и ликвидные USDC-пары, дополняя фиксированный список FIXED_PAIRS).
Потоки регулярных отчетов (start_report_loops), которые по расписанию генерируют ежедневные, еженедельные и другие отчеты (функции generate_daily_report, send_weekly_report и т.д. из stats.py), а также запускают периодические оптимизации (например, tp_optimizer каждые 2 дня и htf_optimizer раз в неделю).
Модуль выбора пар (pair_selector.py) – Содержит логику получения списка доступных фьючерсных инструментов USDC с биржи (через exchange.load_markets) и отбора активных символов. На основе волатильности (calculate_volatility) и объема торгов рассчитывается рейтинг пар; затем формируется итоговый список: комбинация фиксированных пар и топ-динамических пар (в зависимости от баланса выбирается от 5 до 25 пар)​
file-btgyem4bdutqonzdrerqgw
​
file-btgyem4bdutqonzdrerqgw
. Ротация символов сохраняется в файл data/dynamic_symbols.json и сообщается в Telegram.
Ядро стратегии (core.strategy.py и смежные) – Отвечает за сбор рыночных данных и принятие решения, входить в сделку или нет.
Функция fetch_data(symbol) запрашивает через API биржи последние 50 свечей (15m таймфрейм) и рассчитывает индикаторы: RSI, EMA(20), MACD, ATR, ADX, Bollinger Bands и др.​
file-h6xu4badmdq3fnguzlxbzt
​
file-h6xu4badmdq3fnguzlxbzt
.
На основании последних значений индикаторов и предустановленных порогов (FILTER_THRESHOLDS из config.py) выполняется фильтрация сигналов в passes_filters() – отсекаются случаи низкой волатильности (низкие ATR/ADX/BB ширина) с учетом коэффициента relax (адаптивно ослабляет фильтры при необходимости)​
file-h6xu4badmdq3fnguzlxbzt
​
file-h6xu4badmdq3fnguzlxbzt
. Если символ не проходит фильтры, сделка отвергается.
Функция should_enter_trade(symbol, df, ...) реализует логику принятия решения:
Проверяется cooldown: не прошло ли 30 минут с последней сделки по этому символу. Если да, сигнал игнорируется (это предотвращает слишком частый трейдинг)​
file-h6xu4badmdq3fnguzlxbzt
.
Опционально, включена логика пропуска низковолатильных периодов (VOLATILITY_SKIP_ENABLED): если ATR и диапазон свечи слишком малы, сделка не открывается​
file-h6xu4badmdq3fnguzlxbzt
.
После этого вычисляется сводный скоринг (calculate_score) – комбинированная оценка сигнала от 1 до 5, основанная на индикаторах и адаптивных параметрах (учитываются баланс, винрейт и частота сделок)​
file-h6xu4badmdq3fnguzlxbzt
. Вычисляется минимально требуемый скор для входа (get_adaptive_min_score), который снижается при высоком балансе/винрейте или повышается при неудачных сериях.
Если итоговый score меньше порога, вход не происходит (в DRY_RUN это логируется как “No entry”)​
file-h6xu4badmdq3fnguzlxbzt
. Если же скор достаточный, формируется направление сделки (BUY или SELL по отношению MACD к сигнальной линии) и возвращается сигнал на вход.
Smart Re-entry (умное повторное вхождение): Этот блок реализован внутри should_enter_trade. Если по символу уже была недавняя сделка:
Если позиция была закрыта вручную или прошло мало времени (до завершения cooldown) после предыдущей сделки и при этом новая оценка сигнала > 4, то генерируется сигнал ре-ентри​
file-h6xu4badmdq3fnguzlxbzt
​
file-h6xu4badmdq3fnguzlxbzt
. Бот в логах отмечает это как Re-entry и позволит повторно войти сразу, минуя обычную задержку, но только при очень высоком скоре (логика “score > 4”).
Если последняя сделка по символу имела какой-то скор (last_score) и текущий сигнал значительно сильнее (на ≥1.5 пункта), а позиции сейчас нет, то также допускается ре-ентри​
file-h6xu4badmdq3fnguzlxbzt
​
file-h6xu4badmdq3fnguzlxbzt
. В обоих случаях функция возвращает специальный результат с флагом is_reentry=True.
Обычный вход: при штатном условии (score ≥ порога и не сработали условия re-entry) функция помечает текущее время входа в last_trade_times[symbol] (для cooldown)​
file-h6xu4badmdq3fnguzlxbzt
, логирует сигнал и возвращает кортеж с направлением (“buy”/“sell”), значением score и флагом reentry=False​
file-h6xu4badmdq3fnguzlxbzt
​
file-h6xu4badmdq3fnguzlxbzt
.
Модуль обработки символа (symbol_processor.py) – Своего рода связующее звено между стратегией и исполнением сделки. Функция process_symbol(symbol) выполняется для каждого символа:
Проверяет глобальные ограничения: максимальное число одновременных позиций (10 либо 20, в зависимости от баланса) и пропускает символ, если лимит достигнут​
file-3d95hakkuxdq6khydn2tvj
​
file-3d95hakkuxdq6khydn2tvj
. Также пропускается символ, если по нему уже есть открытая позиция (проверяется через trade_engine.get_position_size)​
file-3d95hakkuxdq6khydn2tvj
.
Загружает DataFrame свечей через fetch_data. Если данных нет или произошла ошибка API, символ пропускается​
file-3d95hakkuxdq6khydn2tvj
.
Вызывает should_enter_trade. Если стратегия не дала сигнал (None), то позиция не открывается​
file-3d95hakkuxdq6khydn2tvj
.
Если получен сигнал (направление, скор, флаг ре-ентри), рассчитываются торговые параметры: текущая цена входа, уровень стоп-лосса (SL) как entry _ (1 ± SL_PERCENT), риск на сделку (risk_percent адаптивно через utils_core.get_adaptive_risk_percent) и размер позиции qty через функцию calculate_position_size​
file-3d95hakkuxdq6khydn2tvj
. Если рассчитанный объем слишком мал по нотионалу (меньше MIN_NOTIONAL), сделка отменяется​
file-3d95hakkuxdq6khydn2tvj
.
В логах отображается рассчитанный размер позиции, после чего process_symbol возвращает словарь trade_data с ключевой информацией о потенциальной сделке: символ, направление (buy/sell), количество, цена входа, скор, флаг ре-ентри и др.​
file-3d95hakkuxdq6khydn2tvj
​
file-3d95hakkuxdq6khydn2tvj
. Эта структура потом используется на этапе исполнения.
Контроллер исполнения (core.engine_controller.py) – Управляет торговым циклом и оркеструет взаимодействие между сигналами и исполнением сделок:
Функция run_trading_cycle(symbols) принимает группу символов для проверки​
file-k6v5erujzuuurkbgajvjes
. Сначала обновляется баланс (с кэшированием) и каждые 5 минут логируется его значение​
file-k6v5erujzuuurkbgajvjes
. Также рассчитывается текущее число активных позиций и винрейт недавних свитчей (get_smart_switch_stats()), чтобы определить допустимый лимит срабатываний смарт-свитча на текущий цикл (адаптивный лимит через get_adaptive_switch_limit)​
file-k6v5erujzuuurkbgajvjes
​
file-k6v5erujzuuurkbgajvjes
. Это предотвращает слишком частое закрытие/открытие позиций при Smart Switching.
Далее для каждого символа вызывается process_symbol. Если он вернул None (нет сигнала или не подходит) – цикл переходит к следующему символу​
file-k6v5erujzuuurkbgajvjes
.
Если trade_data получены, контроллер проверяет открыта ли уже позиция через trade_manager. Если по символу есть активная запись трейда (current_trade), то запускается логика 🧠 Smart Switch:
Вычисляется разница нового score и предыдущего (сохраненного в TradeInfoManager). Если новая оценка существенно выше (>= MIN_SCORE_DELTA_SWITCH), и лимит срабатываний на цикл не исчерпан, то бот переключается на новый сигнал​
file-k6v5erujzuuurkbgajvjes
​
file-k6v5erujzuuurkbgajvjes
. В логах и Telegram появляется уведомление о Smart Switch (старый скор vs новый). Бот затем закрывает текущую позицию: в DRY_RUN режиме через close_dry_trade, в боевом режиме через close_real_trade​
file-k6v5erujzuuurkbgajvjes
​
file-k6v5erujzuuurkbgajvjes
. При закрытии позицию он фиксирует время закрытия (trade_manager.set_last_closed_time) и удаляет старый трейд из памяти.
После закрытия smart_switch_count увеличивается, а флаг is_reentry устанавливается в True, чтобы следующий вход трактовался как повторный вход после переключения​
file-k6v5erujzuuurkbgajvjes
​
file-k6v5erujzuuurkbgajvjes
. Далее выполнение не прерывается – обновленный trade_data пойдет в исполнение (фактически сразу открывается новая позиция по тому же символу с новым сигналом).
Если же условие для Smart Switch не выполнено (новый сигнал не намного лучше старого), или лимит переключений исчерпан, то контроллер пропускает открытие новой сделки по этому символу (“Skipping ... current trade score >= new score”)​
file-k6v5erujzuuurkbgajvjes
​
file-k6v5erujzuuurkbgajvjes
.
После возможного Smart Switch, если принято открыть сделку, контроллер инициирует исполнение сделки:
В режиме тестирования (DRY_RUN): сперва вызывается notifier.notify_dry_trade(trade_data) для логирования симуляции (отправляет в Telegram пометки “🧪-DRY-RUN...” и логирует в консоль)​
file-ml5caxzi7oamvjgse6tsh4
. Затем вызов enter_trade происходит даже в DRY_RUN – это сделано для унификации логики и симуляции действий бота, хотя реальных ордеров не выставляется. После этого в DRY_RUN сразу логируется запись через entry_logger.log_entry (с флагом “DRY_RUN”, который внутри просто вызывает log_dry_entry и не пишет в CSV)​
file-mbo5tquhvht2ydsg5r7er2
​
file-mbo5tquhvht2ydsg5r7er2
.
В боевом режиме (REAL_RUN): контроллер напрямую вызывает trade_engine.enter_trade(...) и после успешного выставления ордеров фиксирует запись о входе через entry_logger.log_entry (с режимом “REAL_RUN”, эта функция пишет строку в data/entry_log.csv с деталями сделки)​
file-k6v5erujzuuurkbgajvjes
​
file-mbo5tquhvht2ydsg5r7er2
.
Таким образом, engine_controller связывает воедино: выбор символов, принятие сигнала от стратегии, при необходимости закрытие предыдущей позиции (Smart Switch), и передачу данных в движок исполнения ордеров.
Движок торговли (core.trade_engine.py) – Отвечает за непосредственную работу с ордерами биржи и управление открытыми трейдами:
TradeInfoManager – В начале файла определяется класс-потокобезопасный словарь TradeInfoManager для хранения информации о текущих сделках. Переменная trade_manager (глобальная) используется по всему проекту для записи/чтения активных трейдов. Например, при открытии сделки вызывается trade_manager.add_trade(symbol, trade_data)​
file-lkxtdfakr2ta7gnrcw6rb7
​
file-lkxtdfakr2ta7gnrcw6rb7
, при обновлениях – trade_manager.update_trade(...), а при закрытии – trade_manager.remove_trade(symbol)​
file-lkxtdfakr2ta7gnrcw6rb7
​
file-lkxtdfakr2ta7gnrcw6rb7
. Также TradeInfoManager хранит дополнительные данные: последний score (get_last_score) и время последнего закрытия (get_last_closed_time) по каждому символу – эти методы используются стратегией для реализации re-entry.
Глобальные счетчики: open_positions_count – число открытых позиций, с мьютексом open_positions_lock для синхронизации между потоками​
file-lkxtdfakr2ta7gnrcw6rb7
. Этот счетчик инкрементируется при открытии сделки и декрементируется при фиксировании результата (закрытии). Он служит для ограничения параллельных позиций и корректного завершения работы (ждет пока все позиции закроются).
Функции расчета: calculate_risk_amount(balance, risk_percent) и calculate_position_size(entry, stop, risk_amount) – рассчитывают сумму риска и количество контракта исходя из разницы цены входа/стопа​
file-lkxtdfakr2ta7gnrcw6rb7
. get_position_size(symbol) – узнает текущий размер позиции через API (с использованием кеша позиций)​
file-lkxtdfakr2ta7gnrcw6rb7
.
Открытие сделки: функция enter_trade(symbol, side, qty, score, is_reentry) управляет процессом открытия:
При вызове сразу увеличивает open_positions_count и сохраняет локально данные о цене входа (через биржевое fetch_ticker)​
file-lkxtdfakr2ta7gnrcw6rb7
​
file-lkxtdfakr2ta7gnrcw6rb7
. Если не удалось получить цену или объем слишком мал (qty _ price < MIN_NOTIONAL), сделка отменяется, счетчик откатывается и отправляется предупреждение в Telegram​
file-lkxtdfakr2ta7gnrcw6rb7
​
file-lkxtdfakr2ta7gnrcw6rb7
.
Далее устанавливаются базовые проценты тейк-профитов и стоп-лосса из конфига (TP1_PERCENT, TP2_PERCENT, SL_PERCENT). Если включен флаг AUTO_TP_SL_ENABLED, выполняется автоматическая настройка целей TP/SL под рыночный режим:
Определяется текущий режим рынка (get_market_regime) по ADX на старшем таймфрейме: flat (флэт), trend (тренд) или neutral. В зависимости от режима уменьшаются или увеличиваются величины тейк-профита и стоп-лосса: например, в режиме флэта TP1/TP2/SL уменьшаются (FLAT_ADJUSTMENT < 1)​
file-lkxtdfakr2ta7gnrcw6rb7
, а в трендовом – TP2 и SL увеличиваются (TREND_ADJUSTMENT > 1)​
file-lkxtdfakr2ta7gnrcw6rb7
. Сообщение об этой корректировке выводится в лог.
Дополнительно, если score == 3, предусмотрен особый случай: TP1 и SL уменьшаются на 20%, а второй тейк-профит TP2 отключается (например, более консервативная цель при средних сигналах)​
file-lkxtdfakr2ta7gnrcw6rb7
.
На основе окончательных процентов вычисляются ценовые уровни: tp1_price, tp2_price (если TP2 активен) и sl_price для стоп-ордера​
file-lkxtdfakr2ta7gnrcw6rb7
​
file-lkxtdfakr2ta7gnrcw6rb7
. Также рассчитывается разделение объема на две части: qty_tp1 и qty_tp2 (по долям TP1_SHARE/TP2_SHARE из конфига)​
file-lkxtdfakr2ta7gnrcw6rb7
.
DRY_RUN vs REAL_RUN: если бот в режиме сухого прогона, он не выставляет реальные ордера. В этом случае в логах фиксируется “[DRY] Entering ...” с параметрами сделки, и отправляется Telegram-сообщение с пометкой DRY-RUN​
file-lkxtdfakr2ta7gnrcw6rb7
. Реальные ордера не создаются – таким образом симуляция входа ограничивается логированием и записью в trade_manager. В реальном режиме выполняются сразу три ордера на бирже (через API, обёрнутые функцией безопасного повторного вызова utils_core.safe_call_retry):
Ордер тейк-профит 1 (лимитный ордер на продажу qty_tp1 по tp1_price)​
file-lkxtdfakr2ta7gnrcw6rb7
.
Ордер тейк-профит 2 (если задан tp2_price – лимит на qty_tp2 по этой цене)​
file-lkxtdfakr2ta7gnrcw6rb7
.
Ордер стоп-лосс (тип STOP_MARKET на весь объем, с флагом reduceOnly, по цене sl_price)​
file-lkxtdfakr2ta7gnrcw6rb7
. Все вызовы защищены safe_call_retry – при временных сбоях API будет до 3 попыток выполнить каждый ордер.
После выставления ордеров формируется развернутое Telegram-сообщение о новой сделке (“✅ NEW TRADE”, с указанием Re-entry если применимо, символ, сторона, цены вход/TP/SL, объемы)​
file-lkxtdfakr2ta7gnrcw6rb7
​
file-lkxtdfakr2ta7gnrcw6rb7
, оно отправляется в чат.
Открытая сделка регистрируется: собираются все данные в структуру trade_data (включая флаги tp1_hit=False, tp2_hit=False, soft_exit_hit=False и т.д.)​
file-lkxtdfakr2ta7gnrcw6rb7
​
file-lkxtdfakr2ta7gnrcw6rb7
. Этот словарь сохраняется в trade_manager.add_trade для дальнейшего отслеживания​
file-lkxtdfakr2ta7gnrcw6rb7
.
Далее, если сделка реальная (not DRY_RUN), включаются фоновые механизмы сопровождения позиции:
track_stop_loss(symbol, ...) – сохраняет в общий словарь monitored_stops параметры позиции (символ, сторона, цена входа, количество, время открытия)​
file-lkxtdfakr2ta7gnrcw6rb7
​
file-lkxtdfakr2ta7gnrcw6rb7
. Это используется для мониторинга открытых позиций (в данном коде напрямую не используется, возможно, задел на будущее).
Если включен Trailing Stop (ENABLE_TRAILING=True), запускается поток run_adaptive_trailing_stop для данного символа​
file-lkxtdfakr2ta7gnrcw6rb7
. Эта функция в цикле раз в 5 секунд получает текущую цену и динамически определяет расстояние трейлинга на базе ATR и ADX (больше агрессивность – больше мультипликатор, но при высоком ADX мультипликатор снижается)​
file-lkxtdfakr2ta7gnrcw6rb7
​
file-lkxtdfakr2ta7gnrcw6rb7
. Функция отслеживает максимум (для лонга) или минимум (для шорта) цены с момента входа и при откате >= заданного расстояния мгновенно закрывает всю позицию (маркет-ордером)​
file-lkxtdfakr2ta7gnrcw6rb7
​
file-lkxtdfakr2ta7gnrcw6rb7
. При срабатывании трейлинга в Telegram шлется уведомление “Trailing stop hit...”, и вызывается record_trade_result(..., result_type="trailing") для фиксации результата​
file-lkxtdfakr2ta7gnrcw6rb7
​
file-lkxtdfakr2ta7gnrcw6rb7
.
Если включен Break-Even (ENABLE_BREAKEVEN=True), запускается поток run_break_even​
file-lkxtdfakr2ta7gnrcw6rb7
. Он ждет, когда цена пройдет определенную долю пути до TP1 (порог BREAKEVEN_TRIGGER, например 50%). Когда условие достигнуто, ставится стоп-ордер по цене входа (безубыточность) на весь объем​
file-lkxtdfakr2ta7gnrcw6rb7
​
file-lkxtdfakr2ta7gnrcw6rb7
. Также помечается, что TP1 достигнут (trade_manager.update_trade(symbol, "tp1_hit", True))​
file-lkxtdfakr2ta7gnrcw6rb7
​
file-lkxtdfakr2ta7gnrcw6rb7
и отправляется сообщение “🔒 Break-even activated”. Таким образом, дальнейшая потеря исключена, а частичная фиксация профита отразится в логах как tp1_hit=True.
Если включен Soft Exit (мягкий выход, SOFT_EXIT_ENABLED=True), запускается поток run_soft_exit​
file-lkxtdfakr2ta7gnrcw6rb7
. Этот механизм предназначен для частичной фиксации прибыли до достижения TP1: вычисляется цена soft_exit_price – например, на уровне 30–50% пути к TP1 (задано коэффициентом SOFT_EXIT_THRESHOLD)​
file-lkxtdfakr2ta7gnrcw6rb7
. Когда цена достигает этого уровня, бот продает (или покупает при шорте) часть позиции – долю SOFT_EXIT_SHARE (например 0.5 от объема) по рыночной цене​
file-lkxtdfakr2ta7gnrcw6rb7
​
file-lkxtdfakr2ta7gnrcw6rb7
. Если бот в DRY_RUN, он лишь логирует, что сработал Soft Exit, но ордер не выставляется​
file-lkxtdfakr2ta7gnrcw6rb7
. При реальном Soft Exit в Telegram отправляется уведомление “🔄 Soft Exit {symbol} @ price” и в trade_manager флаг soft_exit_hit ставится True​
file-lkxtdfakr2ta7gnrcw6rb7
​
file-lkxtdfakr2ta7gnrcw6rb7
. После этого поток Soft Exit завершается. Важно: позиция при этом не закрывается полностью – оставшаяся часть продолжает сопровождаться другими механизмами (трейлинг, стоп).
Таким образом, enter_trade завершает открытие: все необходимые ордера выставлены, сопровождающие потоки запущены. В конце функция ничего не возвращает – управление возвращается в engine_controller, который продолжает цикл.
Фиксация закрытия сделки: Когда позиция закрывается (любым способом), вызывается record_trade_result(symbol, side, entry_price, exit_price, result_type). Эта функция:
Уменьшает open_positions_count (через лок) на 1, так как позиция завершается​
file-lkxtdfakr2ta7gnrcw6rb7
​
file-lkxtdfakr2ta7gnrcw6rb7
.
Получает сохраненные данные сделки из trade_manager (если по каким-то причинам запись не найдена, логируется предупреждение)​
file-lkxtdfakr2ta7gnrcw6rb7
.
Рассчитывает длительность удержания позиции в минутах и процент PnL: pnl = ((exit - entry)/entry)*100 (для шорта инвертируется знак)​
file-lkxtdfakr2ta7gnrcw6rb7
. На основании PnL определяется результат “WIN” или “LOSS” для отчета.
Вызывает tp_logger.log_trade_result(...) для записи итога в CSV-лог только если это REAL_RUN. В DRY_RUN внутри log_trade_result сразу выход без действий​
file-enxkz91uukojmm5cyikyhq
. При боевом режиме в CSV файл добавляется строка с полями: Дата/время закрытия, символ, направление, цены входа/выхода, объем, флаги попадания TP1/TP2/SL, процент PnL, длительность, флаг HTF-тренда, ATR/ADX/BB-width на момент входа​
file-enxkz91uukojmm5cyikyhq
​
file-enxkz91uukojmm5cyikyhq
. (Обратите внимание: формат логирования результата в текущей версии включает технические показатели, но не содержит явного поля исхода типа “TP1/TP2/SL” – см. комментарии ниже в проблемах).
Отправляет в Telegram подробное сообщение о закрытии сделки: “📤 Trade Closed [TYPE] ... Entry → Exit, PnL %, held N min”​
file-lkxtdfakr2ta7gnrcw6rb7
. В сообщении указывается тип закрытия (TP, SL, Trailing, Smart Switch и пр. через параметр result_type), а также отмечается “+ Soft Exit”, если часть позиции была продана ранее (soft_exit_hit=True)​
file-lkxtdfakr2ta7gnrcw6rb7
.
Удаляет запись сделки из trade_manager (trade_manager.remove_trade)​
file-lkxtdfakr2ta7gnrcw6rb7
, но через внешние вызовы (например, close_real_trade) тут же сохраняет время закрытия для потенциального re-entry в будущем (set_last_closed_time)​
file-lkxtdfakr2ta7gnrcw6rb7
​
file-lkxtdfakr2ta7gnrcw6rb7
.
Ручное закрытие: Для удобства реализованы функции close_dry_trade(symbol) и close_real_trade(symbol) – они вызываются, например, при Smart Switch или командах Telegram. В DRY_RUN close_dry_trade просто берет последнюю цену и мгновенно вызывает record_trade_result(..., "manual"), имитируя закрытие по рынку​
file-lkxtdfakr2ta7gnrcw6rb7
. В REAL_RUN close_real_trade совершает рыночный ордер противоположного направления на весь объем (закрывая позицию), после чего тоже фиксирует результат через record_trade_result(..., "smart_switch")​
file-lkxtdfakr2ta7gnrcw6rb7
​
file-lkxtdfakr2ta7gnrcw6rb7
. Эти методы позволяют безопасно закрыть позиции по запросу.
Модуль логирования сделок:
entry_logger.py хранит функцию log_entry(trade, status, mode), записывающую факты входа в сделку. В DRY_RUN она просто вызывает log_dry_entry для краткой записи в консоль​
file-mbo5tquhvht2ydsg5r7er2
, а в REAL_RUN добавляет строку в CSV-файл (data/entry_log.csv) со временем входа, символом, направлением, ценой, скором и др.​
file-mbo5tquhvht2ydsg5r7er2
​
file-mbo5tquhvht2ydsg5r7er2
. Эта централизованная запись обеспечивает DRY_RUN-защиту – тестовые запуски не “загрязняют” постоянный лог входов.
tp_logger.py управляет логированием результатов (тейк-профиты/стопы). Функция log_trade_result(...) (вызывается trade_engine-ом) пишет результат только в режиме REAL_RUN​
file-enxkz91uukojmm5cyikyhq
. Она добавляет запись в два CSV: основной файл TP_LOG_FILE (полный лог всех сделок) и укороченный EXPORT_PATH (используется для статистики и отчетов). Оба файла хранят колонки: Дата, Символ, Direction, Entry/Exit Price, Qty, TP1 Hit, TP2 Hit, SL Hit, PnL %, Duration, HTF Confirmed, ATR, ADX, BB Width​
file-enxkz91uukojmm5cyikyhq
​
file-enxkz91uukojmm5cyikyhq
. (Замечание: исходно планировалось поле “Result” для явного указания исхода TP/SL, но текущая реализация вместо этого рассчитывает WIN/LOSS по PnL и помечает хитами TP/SL. Это отмечено ниже как потенциальный недочет.)
Также в tp_logger есть утилиты для чтения результатов: get_last_trade() возвращает последнюю запись из лога, get_human_summary_line() формирует краткую строку о последней сделке, get_trade_stats() подсчитывает общее число сделок и долю выигрышных (по полям Result в CSV). Эти функции используются в отчетах и командах Telegram.
Утилиты:
utils_core.py – включает различные вспомогательные функции:
safe_call_retry(func, *args, tries=3, ...) – единый механизм повторного вызова API с таймаутами на случай сбоев​
file-h55x6jgp6djazssikjerd8
​
file-h55x6jgp6djazssikjerd8
. Он применяется при каждом обращении к бирже (fetch_ticker, create_order, fetch_ohlcv и пр.), повышая надежность работы бота в условиях неустойчивого соединения.
Функции кеширования баланса и позиций: get_cached_balance() и get_cached_positions() хранят последний полученный баланс/позиции и обновляют их не чаще заданного интервала. Это снижает нагрузку на API и ускоряет многократные проверки.
Управление состоянием бота: load_state() и save_state() – читают/пишут JSON-файл состояния (state.json). Бот хранит там флаги pause, stopping, shutdown и, возможно, информацию об ожидающих закрытия сделках. Используется для координации команд /pause, /stop, /shutdown через Telegram и обеспечения, что эти флаги сохраняются между перезапусками процесса​
file-h55x6jgp6djazssikjerd8
​
file-h55x6jgp6djazssikjerd8
. Доступ защищен state_lock во избежание гонок между потоками.
utils_logging.py – настраивает цветной вывод в консоль (с помощью colorama), ведет локальный лог-файл и дублирует важные сообщения в Telegram:
Функция log(message, level, important) пишет строку в файл LOG_FILE_PATH (с ротацией по размеру) и дублирует в stdout (цвет зависит от уровня)​
file-21rbessheqmsu7qgqntu4q
​
file-21rbessheqmsu7qgqntu4q
. Если сообщение важное или уровень ≥ WARNING, оно выводится даже в DRY_RUN.
Специальные функции: notify_error(msg) посылает ошибку в Telegram с ❌, backup_config()/restore_config() сохраняют/восстанавливают backup конфигурации (автоматически вызываются при старте/остановке, успех/ошибки сопровождаются уведомлением)​
file-21rbessheqmsu7qgqntu4q
​
file-21rbessheqmsu7qgqntu4q
, notify_ip_change(old,new,...) формирует предупреждение о смене IP (вызывается из ip_monitor)​
file-21rbessheqmsu7qgqntu4q
​
file-21rbessheqmsu7qgqntu4q
. Эти утилиты повышают надежность – например, при изменении IP автоматически создается backup настроек и бот готовится к остановке.
Telegram утилиты: пакет telegram/_:
telegram_utils.py – содержит функции для отправки сообщений (send_telegram_message) и файлов в Telegram, с учётом MarkdownV2 экранирования​
file-6wmuhgeuvbxztwvnge8edj
​
file-6wmuhgeuvbxztwvnge8edj
. Все сообщения проходят через эту функцию, которая добавляет токен/чат_id из config.py и делает HTTP POST запрос. Предусмотрено усечение слишком длинных сообщений и аварийный повтор без форматирования, если Telegram API вернул ошибку.
telegram_commands.py – реализует обработчики команд. Например, /help отправляет список доступных команд, /summary – сводку последней сделки и основных показателей (винрейт, PnL) через stats.generate_summary(), /pause и /resume управляют state["pause"], /stop устанавливает флаг остановки (бот начнет завершать работу после закрытия позиций) и т.д. Также есть специфичные команды: /router_reboot (включает режим мониторинга IP на 30 минут без остановки бота), /close_dry <symbol> (форсированно закрыть виртуальную позицию в DRY_RUN) и /resume_after_ip (продолжить работу бота после смены IP)​
file-fhwukdhoxi8etgflllknpf
​
file-fhwukdhoxi8etgflllknpf
. Эти команды позволяют гибко контролировать работу бота во время исполнения.
telegram_handler.py – запускает бесконечный цикл, опрашивая Telegram API (getUpdates) с интервалом (в DRY_RUN реже, раз в 60 сек, в боевом чаще – раз в 3 сек, согласно изменениям Priority 0) и при получении сообщений вызывает соответствующие обработчики из telegram_commands. Благодаря этому пользователь может в любой момент дать команду боту и получить отклик, не прерывая основной процесс торговли.
Модули статистики и аналитики:
stats.py – собирает и форматирует данные для отчетов. Ведется словарь trade_stats (в config.py или глобально) с накопленной статистикой: количество win/loss, текущая серия проигрышей, суммарный PnL, депозиты/выводы и т.п. Функция get_safe_stats() возвращает копию этих метрик потокобезопасно​
file-ljbs4tzzripdayx84b8fyv
.
build_performance_report(title, period) формирует текст отчета с основными цифрами (кол-во сделок, винрейт, суммарный PnL, текущий режим агрессивности и короткий комментарий о результате периода)​
file-ljbs4tzzripdayx84b8fyv
​
file-ljbs4tzzripdayx84b8fyv
.
generate_daily_report(days) и аналогичные – читают CSV с результатами (EXPORT_PATH, т.е. tp_performance.csv) и рассчитывают показатели за последний день (или неделю и т.д.): число сделок, винрейт (доля записей с исходом TP1/TP2), суммарный процент прибыли, средний PnL на сделку​
file-ljbs4tzzripdayx84b8fyv
​
file-ljbs4tzzripdayx84b8fyv
, а также текущий relax_factor (коэффициент ослабления фильтров волатильности, берется из core.volatility_controller). Затем текст отчета отправляется в Telegram и логируется​
file-ljbs4tzzripdayx84b8fyv
. В случае ошибок генерации – ловит исключения и уведомляет об ошибке.
Эти отчеты запускаются по таймеру (см. main.py потоки) в определенное время каждый день/неделю, давая пользователю сводку эффективности стратегии.
score_heatmap.py – вероятно, формирует график-heatmap по истории скорингов (упоминается отправка раз в неделю). tp_optimizer.py и tp_optimizer_ml.py – модули для анализа эффективности тейк-профитов, возможно, корректируют значения TP1/TP2 на основе истории (в коде есть упоминания ML-оптимизатора, но детальный разбор этих модулей вне рамок основных функций Priority 1). Они запускаются по расписанию (каждые 2 дня) и могут обновлять конфиг (TP_THRESHOLDS) либо собирать расширенные логи.
В целом, архитектура выстроена вокруг центрального цикла торговли (Trade Engine + Strategy), с рядом поддерживающих сервисов (мониторинг IP, Telegram интерфейс, отчеты, подбор символов). Логика DRY_RUN/REAL_RUN внедрена на всех уровнях – от фильтров стратегии (ослабление порогов в DRY_RUN)​
file-h6xu4badmdq3fnguzlxbzt
​
file-h6xu4badmdq3fnguzlxbzt
до условного выполнения ордеров и логирования. Такая структура облегчает тестирование стратегий в симуляции и переключение в боевой режим без модификации кода. Диаграмма зависимостей модулей в общих чертах:
main.py импортирует и использует: core.engine_controller (цикл торговли), pair_selector (символы), ip_monitor, stats (отчеты), telegram._, tp_optimizer и tp_optimizer_ml, utils_core (для load/save state), utils_logging.
core.engine_controller импортирует: core.strategy, core.trade_engine, symbol_processor, а также utils для баланса (get_cached_balance) и Telegram уведомления (send_telegram_message).
core.strategy использует: core.volatility_controller (фильтры волатильности), core.score_evaluator (скоринг), core.trade_engine (чтобы проверить позиции через trade_manager), tp_logger.get_trade_stats (винрейт для адаптации), utils (баланс, safe_call_retry) и Telegram для уведомлений.
core.trade_engine использует: core.aggressiveness_controller (оценка режима для трейлинга), tp_logger.log_trade_result, utils_core.safe_call_retry, utils_logging и Telegram utils.
symbol_processor использует: core.strategy и core.trade_engine (расчеты), а также utils_core (риск % и баланс).
ip_monitor использует: telegram_utils для уведомлений, utils_logging и config для настроек.
utils_core/utils_logging – утилитарные, почти во всех модулях используются их функции (safe_call_retry, log, send_telegram_message и т.д.).
telegram_handler/commands используют stats, pair_selector, ip_monitor и функции core (например, handle_stop вызывает остановку в engine_controller через state flags).
stats.py использует core.aggressiveness_controller и core.volatility_controller (для режима и relax_factor), tp_logger (чтение лога сделок) и Telegram utils для отправки.
Такая модульная структура делает систему достаточно читабельной: каждый компонент отвечает за свою часть (стратегия, ведение ордеров, отчеты, связь и т.д.), взаимодействие происходит через четко определенные функции и глобальные структуры, что повышает поддерживаемость.
Потенциальные проблемы и недочеты
Несоответствие формата логов результатов и статистики. В tp_logger.log_trade_result записываются колонки без явного поля исхода сделки. Например, нет колонки “Result” (TP1/TP2/SL), хотя в коде статистики и в документации она предполагается. Функция get_trade_stats() ищет в CSV столбец Result для определения winrate​
file-enxkz91uukojmm5cyikyhq
, но текущий заголовок EXPORT_PATH содержит только технические поля (HTF Confirmed, ATR и др.)​
file-enxkz91uukojmm5cyikyhq
​
file-enxkz91uukojmm5cyikyhq
. Это рассинхронизировано с ожиданиями: например, generate_daily_report считает win_trades по df["Result"].isin(["TP1","TP2"])​
file-ljbs4tzzripdayx84b8fyv
, что приведет к ошибке, так как столбца Result может не быть. Вероятно, планировалось записывать тип исхода (TP1, TP2, SL, trailing, etc.) в CSV, но сейчас этого нет – лишь косвенно можно понять по флагам hit и знаку PnL. Возможный баг: отчеты могут некорректно работать или не учитывать частичные тейк-профиты, из-за отсутствия явного поля Result. Нужно унифицировать формат: либо добавить колонку Result при логировании, либо исправить код статистики использовать комбинации флагов (tp1_hit, tp2_hit, sl_hit) для определения исхода сделки.
Неучтенный PnL при Soft Exit. Механизм Soft Exit продает часть позиции до основного выхода, но при финальном расчете PnL в record_trade_result это не отражается. Формула PnL берёт только начальный и конечный цены позиции​
file-lkxtdfakr2ta7gnrcw6rb7
, поэтому если, к примеру, половина позиции была продана по более высокой цене, а остаток закрыт по стопу (ниже входа), фактический суммарный результат мог быть около нуля или даже плюсовой, но формула покажет убыток (рассчитанный по последней цене выхода на весь объем). Флаг soft_exit_hit=True учитывается только для пометки в сообщении, но не корректирует расчет PnL. Это ведет к неточной статистике: бот может занижать винрейт и PnL по сделкам с частичной фиксацией. Аналогично, при срабатывании трейлинг-стопа после TP1, первый тейк (tp1_hit) не увеличивает PnL, т.к. формула все еще считает от начальной цены до финальной. Недочет: следовало бы скорректировать логику расчета прибыли с учетом частичного закрытия. Например, рассчитывать эффективный средний exit price или разбивать сделку на две записи (TP и остаток) в логе. В текущей версии это упущение может запутать пользователя отчета (он видит “Soft Exit hit” в сообщении, но результат сделки может числиться как LOSS при положительном куме).
Глобальный счетчик позиций в DRY_RUN. Переменная open_positions_count увеличивается при каждом вызове enter_trade даже в режиме DRY_RUN​
file-lkxtdfakr2ta7gnrcw6rb7
​
file-lkxtdfakr2ta7gnrcw6rb7
, а уменьшается только когда вызывается record_trade_result (что в DRY_RUN обычно не происходит, т.к. сделки виртуальные). В результате при длительном запуске в тестовом режиме счетчик будет расти с каждой смоделированной сделкой и может достичь max_open_positions, после чего symbol_processor начнет пропускать новые сигналы​
file-3d95hakkuxdq6khydn2tvj
, ошибочно считая, что уже открыто слишком много позиций. При этом реальные позиции отсутствуют (get_position_size в DRY_RUN возвращает 0, т.к. нет открытых ордеров). Это логический конфликт: бот может “застрять” в DRY_RUN, перестав открывать новые виртуальные сделки из-за искусственного лимита. Предусмотрена команда /close_dry <symbol> для ручного закрытия симулятивной позиции​
file-fhwukdhoxi8etgflllknpf
, но она требует знать, какие символы “открыты” виртуально (такая инфо не выводится автоматически, кроме как в логах). Потенциальная проблема: рост open_positions_count без сброса. Необходимо либо сбрасывать/уменьшать этот счетчик в DRY_RUN (например, сразу после имитации входа, либо периодически), либо вести отдельный счетчик для реальных позиций. Одно решение – в функции log_entry при DRY_RUN сразу вычитать позицию, раз она лишь для лога, или вообще не трогать open_positions_count в DRY_RUN. Это сделает тестовый режим более стабильным для длительного прогона.
Гонки между last_trade_times и TradeInfoManager. Код стратегии использует два источника для данных о предыдущих сделках:
Глобальный словарь last_trade_times (с отдельным lock) – хранит время последнего входа по символу для cooldown.
TradeInfoManager (trade_manager) – хранит last_closed_time и last_score для реализации re-entry. Эти механизмы работают совместно, но есть нюанс: после закрытия сделки trade_manager.remove_trade убирает запись, затем set_last_closed_time записывает время закрытия в новый пустой слот (но уже без score)​
file-lkxtdfakr2ta7gnrcw6rb7
​
file-lkxtdfakr2ta7gnrcw6rb7
. Таким образом, trade_manager.get_last_score(symbol) вернет 0 после закрытия сделки (так как score удален). В стратегии условие re-entry “если score вырос на ≥1.5 относительно предыдущего” проверяется через last_score​
file-h6xu4badmdq3fnguzlxbzt
​
file-h6xu4badmdq3fnguzlxbzt
, но last_score будет 0 (false) после закрытия. То есть повторный вход из-за улучшения сигнала не сработает, если предыдущая позиция полностью закрыта – он сработает только пока старая позиция еще открыта (что покрыто SmartSwitch) либо если trade_manager временно не очистил score. Возможно, так и задумано (ре-ентри по улучшенному скору актуален только при свитче активной позиции), но логика немного запутанная: наличие двух хранилищ данных может привести к тому, что при очень быстром закрытии и новом сигнале elapsed < cooldown ветка re-entry по времени схватится вместо ветки по улучшенному скору. Это не критично, но может стоить объединить хранение последних данных по символу в одном месте. Например, добавить в TradeInfoManager поле последнего score закрытой сделки. Тогда можно избавиться от глобального last_trade_times и полностью доверять trade_manager для всех условий (хранить там и время последнего входа, и время закрытия, и score). Сейчас же есть небольшое дублирование: время входа хранится отдельно, время закрытия – в другом месте.
Остановка бота через /stop и завершение потоков. Механизм остановки реализован путем установки флага stopping в state и ожидания, пока все открытые позиции закроются​
file-k6v5erujzuuurkbgajvjes
​
file-k6v5erujzuuurkbgajvjes
. В engine_controller при каждом цикле проверяется этот флаг: если stopping=True, а открытых трейдов нет – бот выходит (и если shutdown=True, то делает os.\_exit(0) принудительно)​
file-k6v5erujzuuurkbgajvjes
​
file-k6v5erujzuuurkbgajvjes
. Это гарантирует корректное завершение основного цикла. Однако, использование os.\_exit(0) завершает процесс мгновенно, не давая закрывающимся потокам (репорты, мониторинг) корректно завершиться. В результате, например, лог-файл может не сброситься, или другие ресурсы не освободиться. Риск небольшой (бот в основном пишет файлы регулярно, и os.\_exit тут осознанно применен для надежного отключения), но более “чистым” решением было бы сигнализировать всем потокам о завершении. Например, можно завести глобальный флаг завершения и проверять его внутри бесконечных циклов (в start_report_loops, start_symbol_rotation, start_ip_monitor), чтобы аккуратно выйти из них. Это повысило бы стабильность при многократном запуске-остановке бота, хотя в текущем виде проблем не наблюдается, так как при shutdown предполагается прекращение всего процесса.
Потенциальная нагрузка и задержки. В текущей реализации все сетевые вызовы (API биржи, Telegram) выполняются синхронно в отдельных потоках, что, как правило, нормально. Но есть места, где могут быть задержки:
Функция fetch_all_symbols в pair_selector может быть тяжелой – она загружает все рынки (сотни символов) и потом еще вызывает fetch_ohlcv по каждому из ~30 лучших символов для оценки волатильности​
file-btgyem4bdutqonzdrerqgw
​
file-btgyem4bdutqonzdrerqgw
. Это происходит раз в час, в отдельном потоке, и может занимать десятки секунд. Если в это время основной поток торговли тоже делает API-вызовы, может быть некоторый скачок нагрузки. Пока это не создает явной проблемы (разные потоки, Safe Retry разгрузит пиковые ошибки), но следует следить за производительностью. Улучшение могло бы заключаться в асинхронном или батчевом запросе данных для нескольких символов сразу, либо кешировании волатильности, чтобы не пересчитывать каждый час с нуля для всех.
В telegram_handler, при DRY_RUN опрос API раз в 60 секунд – это сделано для снижения шума в тесте. Однако, если пользователь в DRY_RUN отправит команду, ответ придет с задержкой до минуты. Это приемлемо, но можно было бы слушать чаще или сразу по команде от пользователя не ждать цикл. В REAL_RUN (3 сек интервал) таких проблем нет.
Читаемость кода и дублирование логики. В целом код хорошо прокомментирован и разбит на функции, однако есть небольшие повторы:
Формирование Telegram-сообщений для одних и тех же событий разбросано по коду. Например, уведомление о ре-ентри формируется и в стратегии (DRY_RUN случай)​
file-h6xu4badmdq3fnguzlxbzt
, и в enter_trade (в сообщении “NEW TRADE (Re-entry)” при реальном входе)​
file-lkxtdfakr2ta7gnrcw6rb7
. Они немного отличаются по формату. Можно централизовать шаблоны сообщений, чтобы стиль уведомлений был единообразным.
Пороговые значения и константы разбросаны по config.py. Например, MIN_SCORE_DELTA_SWITCH, BREAKEVEN_TRIGGER, SOFT_EXIT_THRESHOLD – все настроечки, влияющие на логику. Стоило бы сгруппировать их в конфиге по функциональным блокам (например, блок SmartSwitch, блок RiskManagement) или хотя бы дать более очевидные комментарии в config. Сейчас понимание, за что отвечает та или иная константа, требует чтения кода (хотя названия достаточно говорящие).
Документация vs код: В документации (MASTER PLAN v1.6.2) отмечено, что Soft Exit и Re-entry “❌ не начинали” на момент планирования​
file-vksg6mj1tgbvgbyhta9b96
, но в коде эти функции уже есть. Возможно, реализации еще свежие, и стоит убедиться, что они полноценно протестированы. Например, ре-ентри при улучшении score – новая логика, важно проверить на исторических данных или бэктестах, что она действительно улучшает результаты. Сейчас ее параметры (разница ≥1.5) выбраны интуитивно; возможно, потребуется калибровка.
Безопасность и устойчивость. В целом, проект уделяет внимание отказоустойчивости (safe_call_retry, ловля исключений, резервное копирование конфигов). Тем не менее, некоторые моменты:
Внешние запросы: использование requests для Telegram и IP мониторинга без явного контроля ошибок. Хотя есть try/except, но, например, requests.get(ipify) в get_current_ip не имеет таймаута​
file-khpr4su3quufvmsox6nr6q
– потенциально, если сервис зависнет, поток может подвиснуть надолго. Лучше задать timeout=5 при запросе IP.
API-ключи: токен Telegram и ключи биржи берутся из config.py. В коде они не логируются (и правильно), но стоит убедиться, что нигде исключения (например, при ошибке requests) не выведут чувствительные данные. Пока таких мест не видно.
Отсутствие явных уязвимостей: код не принимает внешнего ввода (кроме Telegram команд, которые ограничены предусмотренным списком), поэтому угроз SQL-инъекций или исполнения кода нет. Главное – сохранять API-ключи и токены в тайне, а с этим справляется.
Подытоживая: несмотря на приведенные выше недочеты, общая логика выглядит корректной и достаточно надежной. Режимы DRY_RUN/REAL_RUN учтены практически в каждом критичном месте (от формирования сигналов до записи логов), минимизируя риск некорректной работы. Возможные проблемы с логированием и частичными выходами можно исправить точечными улучшениями.
Рекомендации по улучшению
На базе выявленных моментов, вот список рекомендаций для повышения надежности, читабельности и расширяемости кода:
Единый формат логов результатов: Скорректировать tp_logger и stats. Желательно добавить в CSV поле явного исхода сделки. Например, записывать “TP1” / “TP2” / “SL” / “Trailing” / “Manual” и т.п. Тогда отчеты смогут напрямую группировать результаты. Альтернативно, можно поправить функции статистики, чтобы они выводили винрейт на основе комбинации флагов (например, считать выигрышами строки, где SL Hit = False и PnL > 0). Ясность данных логов важна для доверия к отчетам – сейчас пользователю непонятно, что считать “win”. Добавление столбца Result решило бы это (в record_trade_result можно определить результат по result_type и флагам и передать в log_trade_result). Также убедиться, что entry_logger и tp_logger согласованы с DRY_RUN: в идеале, DRY_RUN-действия вообще не должны писать в итоговые CSV (сейчас так и сделано), поэтому эти функции реализованы правильно, просто их вывод стоит проверить в боевом режиме.
Учесть частичные закрытия при расчете PnL: Можно улучшить record_trade_result. Например, если soft_exit_hit=True, посчитать эффективный выход как средневзвешенную цену: половина объема по soft_exit_price, половина по final_exit – и на основе этого пересчитать PnL%. Либо хотя бы помечать такие сделки особым исходом “Partial” и в статистике обрабатывать отдельно. Сейчас Soft Exit выполняет свою функцию (снижает риск), но его эффект не прозрачен в логах. Подобное улучшение повысит точность статистики и доверие к ней – пользователь увидит, что, скажем, сделка закрыта частично пораньше и убыток сокращен, а не полный стоп-лосс.
Разделить учет позиций в симуляции и реальности: Для DRY_RUN можно либо не использовать open_positions_count вообще, либо сбрасывать его. Один вариант: обнулять open_positions_count при каждом цикле в DRY_RUN (т.к. это ведь симуляция, можно считать, что “виртуальные сделки” не ограничены по количеству). Если же хочется ограничивать и в DRY_RUN, то нужно правильно декрементировать: добавить, например, таймаут удержания виртуальной позиции и автоматическое закрытие. Кстати, можно расширить /close_dry – сделать без символа, чтобы она закрывала все открытые DRY-позиции разом. Сейчас open_positions_count в DRY_RUN скорее мешает, поэтому проще при DRY_RUN=True не учитывать его в process_symbol (пропускать проверку лимита и не инкрементировать на входе). Это не повлияет на реальный режим, но избавит от ложных ограничений в тестах.
Упрощение хранения временных меток сделок: Объединить last_trade_times и trade_manager хотя бы частично. Например, можно хранить в trade_manager.\_trades[symbol] поля last_entry_time и last_close_time. Тогда стратегия может читать их через общие методы и удалить необходимость держать отдельный словарь с lock. Меньше глобальных сущностей – меньше риска забыть их обновить синхронно. В нынешнем виде это не приводит к багам, но есть избыточность: например, при открытии сделки last_trade_times обновляется​
file-h6xu4badmdq3fnguzlxbzt
, а информация о времени входа хранится еще и косвенно (через start_time в trade_data внутри trade_manager). Потенциально можно использовать только trade_manager во всех местах.
Безопасное завершение потоков: Рассмотреть более мягкий способ остановки, чем os.\_exit. Например, установить некий глобальный флаг SHUTDOWN=True и в каждом фоновой цикле (report_loops, rotation, monitor) делать break при его обнаружении. Тогда при /shutdown основная логика дождется закрытия позиций, установит SHUTDOWN, и все потоки аккуратно выйдут. В конце main.py можно просто sys.exit(0) вызвать, который выполнится после завершения потоков. Хотя os.\_exit работает, он может затруднить расширяемость (например, если в будущем нужно выполнять какие-то действия при штатном завершении, они не выполнятся).
Оптимизация динамического выбора пар: Если fetch_all_symbols начинает съедать много времени или API-лимитов, стоит внедрить кеширование. Например, обновлять список рынков не каждый час с нуля, а получать только изменения (у Binance/CCXT иногда есть метка обновления рынков). Либо хотя бы уменьшить количество символов, по которым собираются данные для волатильности – сейчас берется топ-30. Можно брать топ-50 по объемам, а из них выбирать 30 по волатильности, избегая лишних запросов. Также, calculate_volatility можно вынести отдельно (в коде не показан, вероятно считает что-то вроде ATR% за период), его можно оптимизировать, чтобы не пересчитывать на каждую итерацию цикла.
Логгирование и уведомления: Убедиться, что все важные события покрыты. Например, сейчас при срабатывании TP1 и последующем закрытии по SL бот отметит в CSV TP1 Hit = True и Result = LOSS (если добавить поле) – стоит ли прислать отдельное уведомление, что хотя TP1 достигнут, сделка закрылась по стопу? Возможно, достаточно текущего сообщения о закрытии с пометкой. Но такие нюансы стоит продумать с точки зрения пользователя: прозрачность действий бота – ключ к доверию. Например, можно в сообщении о закрытии указывать, сколько долей позиции закрыто на каких уровнях (хотя бы “TP1 hit: yes/no”).
Дополнительные проверки ошибок: добавить timeout для запроса IP, логировать тело исключения при провалах API (сейчас много где просто log(..., level="ERROR") выводит e, этого достаточно, но можно классифицировать тип ошибок – сеть, авторизация и т.д.). Можно также предусмотреть автоматическую паузу при серии ошибок API (например, если 5 раз подряд safe_call_retry вернул None, возможно, ключ недействителен – стоит остановить бот). Таких ситуаций маловероятно, но для надежности можно добавить.
Документация и конфиг: Обновить README/документацию под реальное состояние функций (отметить, что Smart Re-entry и Soft Exit реализованы). Кроме того, рассмотреть группировку параметров в config.py. Сейчас файл конфигурации скорее всего содержит десятки констант. Для удобства можно разделить на секции (например, словари или просто комментариями): Risk management, Strategy filters, Features toggles, API keys, etc. Это поможет новым разработчикам быстрее понимать настройки. Также повторяющиеся значения (например, 30 минут cooldown фигурирует и в стратегии, и в ip_monitor в другом контексте) – вынести в именованные константы.
Тестирование новых функций: Рекомендуется провести тщательное тестирование блоков Smart Re-entry и Soft Exit на исторических данных или в sandbox. Особенно Smart Re-entry – убедиться, что он действительно повышает прибыль, а не приводит к лишним перетрейдам. Порог score > 4 в условиях cooldown выглядит разумно, но, возможно, стоит сделать его настраиваемым в конфиге (например, REENTRY_SCORE_THRESHOLD = 4). То же касается разницы 1.5 для re-entry после закрытия – эти числа лучше проверять экспериментально. Возможно, имеет смысл добавить в Telegram команду, позволяющую включать/выключать Smart Switch и Re-entry на лету, чтобы оператор мог гибко управлять агрессивностью стратегии.
Расширяемость: Если планируется добавлять новые источники сигналов или логики (например, Open Interest, REST API, которые помечены как не начатые в плане), текущая архитектура позволяет это довольно легко. Тем не менее, нужно сохранить принцип модульности: выносить новую логику в отдельные модули/классы. Например, логику Open Interest – как отдельный модуль, который интегрируется в strategy.should_enter_trade (через доп. фильтр). В будущем, возможно, стоит рассмотреть переход на объектно-ориентированную модель для управления стратегиями – сейчас много глобальных переменных, которые сложно передавать, если будет несколько стратегий. Но пока проект рассчитан на одну стратегию, это не мешает.
В целом, рекомендации сводятся к улучшению прозрачности и надежности. Исправив мелкие баги с логированием и учётом частичных выходов, вы повысите точность отчётов. Оптимизация и рефакторинг (объединение структур, чуть более аккуратное завершение) сделают кодbase более чистым, особенно перед дальнейшим расширением функционала.
