"""
Strategy Manager for coordinating different trading strategies
"""

from typing import Any

import pandas as pd

from core.config import TradingConfig
from core.exchange_client import OptimizedExchangeClient
from core.symbol_manager import SymbolManager
from core.unified_logger import UnifiedLogger
from strategies.scalping_v1 import ScalpingV1


class StrategyManager:
    """Manages different trading strategies"""

    def __init__(
        self,
        config: TradingConfig,
        exchange: OptimizedExchangeClient,
        symbol_manager: SymbolManager,
        logger: UnifiedLogger,
    ):
        self.config = config
        self.exchange = exchange
        self.symbol_manager = symbol_manager
        self.logger = logger

        # Initialize strategies
        self.strategies = {"scalping_v1": ScalpingV1(config, logger)}

        # Current active strategy
        self.active_strategy = "scalping_v1"

        # Strategy performance tracking
        self.strategy_stats = {
            "scalping_v1": {"signals_generated": 0, "trades_executed": 0, "successful_trades": 0, "failed_trades": 0}
        }

        self.logger.log_event(
            "STRATEGY_MANAGER", "INFO", f"Strategy manager initialized with active strategy: {self.active_strategy}"
        )

    def get_active_strategy(self):
        """Get the currently active strategy"""
        return self.strategies.get(self.active_strategy)

    async def evaluate_symbol(self, symbol: str) -> tuple[str | None, dict[str, Any]]:
        """
        Evaluate a symbol using the active strategy

        Returns:
            Tuple of (direction, breakdown) where:
            - direction: "buy", "sell", or None
            - breakdown: Dict with signal analysis details
        """
        try:
            # Get OHLCV data for the symbol
            df = await self._fetch_ohlcv_data(symbol)
            if df is None or df.empty:
                self.logger.log_event("STRATEGY_MANAGER", "WARNING", f"{symbol}: No OHLCV data available")
                return None, {"reason": "no_data"}

            # Use active strategy to evaluate
            strategy = self.get_active_strategy()
            if not strategy:
                self.logger.log_event("STRATEGY_MANAGER", "ERROR", "No active strategy available")
                return None, {"reason": "no_strategy"}

            direction, breakdown = await strategy.should_enter_trade(symbol, df)

            if direction:
                # Update strategy statistics
                self.strategy_stats[self.active_strategy]["signals_generated"] += 1
                breakdown["strategy"] = self.active_strategy

                self.logger.log_event(
                    "STRATEGY_MANAGER", "INFO", f"{symbol}: Signal generated by {self.active_strategy} - {direction}"
                )

            return direction, breakdown

        except Exception as e:
            self.logger.log_event("STRATEGY_MANAGER", "ERROR", f"{symbol}: Error in strategy evaluation: {e}")
            return None, {"error": str(e)}

    async def _fetch_ohlcv_data(self, symbol: str, timeframe: str = "5m", limit: int = 100) -> pd.DataFrame | None:
        """Fetch OHLCV data for a symbol"""
        try:
            if not self.exchange.is_initialized:
                self.logger.log_event("STRATEGY_MANAGER", "ERROR", "Exchange not initialized")
                return None

            ohlcv = await self.exchange.fetch_ohlcv(symbol, timeframe, limit)
            if not ohlcv or len(ohlcv) < 30:
                self.logger.log_event("STRATEGY_MANAGER", "WARNING", f"{symbol}: Insufficient OHLCV data")
                return None

            # Convert to DataFrame
            df = pd.DataFrame(ohlcv, columns=["timestamp", "open", "high", "low", "close", "volume"])
            df["timestamp"] = pd.to_datetime(df["timestamp"], unit="ms")
            df.set_index("timestamp", inplace=True)

            return df

        except Exception as e:
            self.logger.log_event("STRATEGY_MANAGER", "ERROR", f"{symbol}: Error fetching OHLCV data: {e}")
            return None

    def switch_strategy(self, strategy_name: str) -> bool:
        """Switch to a different strategy"""
        if strategy_name not in self.strategies:
            self.logger.log_event("STRATEGY_MANAGER", "ERROR", f"Strategy {strategy_name} not found")
            return False

        self.active_strategy = strategy_name
        self.logger.log_event("STRATEGY_MANAGER", "INFO", f"Switched to strategy: {strategy_name}")
        return True

    def get_strategy_stats(self) -> dict[str, Any]:
        """Get statistics for all strategies"""
        return {
            "active_strategy": self.active_strategy,
            "available_strategies": list(self.strategies.keys()),
            "statistics": self.strategy_stats,
        }

    def record_trade_result(self, symbol: str, direction: str, success: bool):
        """Record the result of a trade for statistics"""
        try:
            stats = self.strategy_stats.get(self.active_strategy, {})
            stats["trades_executed"] += 1

            if success:
                stats["successful_trades"] += 1
            else:
                stats["failed_trades"] += 1

            self.logger.log_event(
                "STRATEGY_MANAGER",
                "INFO",
                f"{symbol}: Trade {direction} {'successful' if success else 'failed'} - "
                f"Stats: {stats['successful_trades']}/{stats['trades_executed']} successful",
            )

        except Exception as e:
            self.logger.log_event("STRATEGY_MANAGER", "ERROR", f"Error recording trade result: {e}")

    async def scan_for_opportunities(self) -> list[tuple[str, str, dict[str, Any]]]:
        """
        Scan all available symbols for trading opportunities

        Returns:
            List of (symbol, direction, breakdown) tuples
        """
        opportunities = []

        try:
            symbols = await self.symbol_manager.get_available_symbols()

            for symbol in symbols[:5]:  # Check top 5 symbols
                try:
                    direction, breakdown = await self.evaluate_symbol(symbol)

                    if direction:
                        opportunities.append((symbol, direction, breakdown))

                except Exception as e:
                    self.logger.log_event("STRATEGY_MANAGER", "DEBUG", f"Error evaluating {symbol}: {e}")
                    continue

            if opportunities:
                self.logger.log_event("STRATEGY_MANAGER", "INFO", f"Found {len(opportunities)} trading opportunities")

            return opportunities

        except Exception as e:
            self.logger.log_event("STRATEGY_MANAGER", "ERROR", f"Error scanning for opportunities: {e}")
            return []
